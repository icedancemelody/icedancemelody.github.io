<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统回顾-进程管理</title>
      <link href="/2021/07/13/jin-cheng-guan-li/"/>
      <url>/2021/07/13/jin-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>为什么会有中断？</p><p>因为在早期，计算机执行程序的方式必须是串行的。程序放入计算机内存后需要等待其运行结束，才被移出内存。且每一道程序都是串行执行，这导致了系统资源利用率很低。</p><p>为了解决这个问题，首先人们先发明了操作系统，并引入了中断机制，其本质是：发生中断意味着需要操作系统介入，开展管理工作。中断机制涉及到的相关知识为：</p><ul><li>CPU会运行两种程序，一种是操作系统内核程序，一种是应用程序。分别对应CPU的两种态势：核心态和用户态。且CPU一般情况下是处于用户态运行应用程序。</li><li>发生中断后，操作系统介入，且CPU立即转变为核心态。</li><li>当中断发生后，当前CPU正在运行的进程会停止运行（挂起），CPU转为处理中断请求。</li></ul><h2 id="CPU处理中断的过程"><a href="#CPU处理中断的过程" class="headerlink" title="CPU处理中断的过程"></a>CPU处理中断的过程</h2><p>CPU在用户态运行的好好的，它什么时候会发现有打断它正常工作的突发事件呢？</p><ul><li>CPU通常在用户态下按顺序执行用户程序的每条指令，执行完每条指令后，CPU都会检查当前是否有外部中断信号，没有则继续执行指令。</li><li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（程序状态字PSW、程序计数器PC、通用寄存器等）</li></ul><h2 id="核心态-gt-用户态"><a href="#核心态-gt-用户态" class="headerlink" title="核心态->用户态"></a>核心态-&gt;用户态</h2><ul><li>一般情况下，操作系统内核会把CPU的使用权主动让给应用程序，即转变为用户态。(只要我不用，一般它都是用户的)</li><li>执行一条特权指令——修改程序状态字PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li></ul><h2 id="用户态-gt-核心态"><a href="#用户态-gt-核心态" class="headerlink" title="用户态->核心态"></a>用户态-&gt;核心态</h2><ul><li>中断一旦出现，硬件自动转变为核心态，操作系统带着中断程序抢占CPU使用权</li><li>中断是让操作系统内核夺回CPU使用权的<strong>唯一途径</strong></li></ul><p>那么哪些发生的事件属于中断呢？</p><h2 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h2><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>内中断与当前执行的指令有关，中断信号来源于CPU内部，也称为异常。</p><p>这种异常主要可分为三类：</p><ul><li>陷入：由陷入指令引发，是应用程序故意引发的，有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的</li><li>故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行。例如缺页故障。</li><li>终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。若当前执行的指令是非法的，则会引发一个中断信号。例如执行除法指令时发现除数为 0、试图在用户态下执行特权指令</li></ul><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><ul><li>与当前执行的指令无关，中断信号来源于CPU外部</li><li>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</li><li>例如：时钟中断——由时钟部件发来的中断信号、IO中断请求</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用就是刚刚的内中断中的陷入指令，其主要出现情况是用户态程序想要借助操作系统内核实现一些特殊功能。这是一种由用户态程序自包含的一种请求使用操作系统功能服务的指令。</p><ul><li>运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能则要用到系统调用</li><li>运行的用户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</li><li>由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li><li>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>在发起系统调用指令后，CPU对系统调用的执行过程为：</p><ul><li>传递系统调用参数-&gt; 执行陷入指令（用户态）-&gt; 执行相应的内请求核程序处理系统调用（核心态）-&gt; 返回应用程序</li><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li><li>陷入指令 = trap 指令 = 访管指令</li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>程序段</li><li>数据段</li><li>进程控制块（PCB)<ul><li>操作系统对进程进行管理所需要的信息都在PCB中</li><li>当OS要调度某进程执行时，要从PCB中查看其状态以及其优先级</li><li>当调度到某个进程后，要根据其PCB中保存的处理机状态信息，设置该进程恢复运行的现场。</li><li>包括进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息等。</li></ul></li></ul><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul><li>创建：进程正在被创建，创建程序段、数据段、PCB信息</li><li>就绪：进程创建好了，并被操作系统分配了除了CPU处理机之外的一切其他资源（内存，I/O设备等）。一旦得到处理机资源（处理机分配的时间片）既可以运行</li><li>运行：进程正在处理机上运行（单核CPU下，任意时刻只有一个进程处于运行状态）。</li><li>阻塞：又称为等待，进程正在等待某一事件而暂停运行，如等待某资源可用或等待IO操作完成。即使处理机是空闲的，该进程也不能运行</li><li>结束：进程正在从系统中消失，可能时进程正常结束，也可能是其他原因中断退出运行。</li><li>就绪挂起，挂起态是将进程映像调到外存，阻塞态进程映像还在内存中</li><li>阻塞挂起</li></ul><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>每一个进程是资源分配的基本单位。</p><p>进程结构由以下几个部分组成：代码段，堆栈段，数据段。</p><ul><li><p>代码段是静态的二进制代码</p></li><li><p>堆栈段</p><p>　1. 为函数内部的局部变量提供存储空间。</p><p>　2. 进行函数调用时，存储“过程活动记录”。</p><p> 　3. 用作暂时存储区。如计算一个很长的算术表达式时，可以将部分          计算结果压入堆栈。</p><p>栈区（stack）：由编译器自动分配释放 ，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。<br>堆区（heap）：由程序员分配释放， 若程序员不释放，程序结束时可能由操作系统回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 </p></li><li><p>数据段</p><p>包括BSS段（Block Started by Symbol）的数据段。BSS段存储未初始化或初始化为0的全局变量、静态变量，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。数据段存储经过初始化的全局和静态变量。</p></li></ul><p>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。</p><p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p><p>如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p><p>我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。 　　</p><p>让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 　　　　</p><p>在切换时，一个进程存储在处理器各寄存器中的中间数据叫做<strong>进程的上下文</strong>，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存储在<strong>进程的私有堆栈</strong>中的。 　 </p><p>　　显然，进程的切换可以用<strong>中断技术</strong>来实现，即当调度器获得了待运行进程的控制块之后，应立即用软中断指令来中止当前进程的运行，并保存当前进程的PC值和PSW值。其后，使用压栈指令把处理器其他寄存器的值压入进程私有堆栈。接下来，就从待运行进程的进程控制块中取出<strong>私有堆栈指针的值并存入处理器的寄存器SP</strong>，至此SP就指向了待运行进程的私有堆栈，于是下面就自待运行进程的私有堆栈中弹出上下文进入处理器。最后，利用中断返回指令来实现自待运行进程的私有堆栈中弹出PSW值和自待运行进程的 私有堆栈中弹出PC值的功能。 　　</p><p>这是一个完整的软中断处理过程，只不过在保护现场和恢复现场工作中，保护的是被中止运行进程的现场，恢复的是待运行进程的现场，这一切都依赖于堆栈指针的切换。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>切出： 一个线程被剥夺处理器的使用权而被暂停运行<br>切入： 一个线程被系统选中占用处理器开始或继续运行</p><p>上下文，一般包括<strong>通用寄存器和程序计数器</strong>的内容。在切出时，操作系统会将线程的进度信息保存到内存。在切入时，操作系统需要从内存中加载线程的上下文。</p><p>在单核cpu中，多线程的执行是通过cpu的时间片分配，每个线程会分配到一个时间片，循环执行这些线程，线程时间片消耗完了就会进入等待状态，直到分配到新的时间片，因为时间片的时间非常短，所以cpu不停的切换线程执行，给我们造成了多线程同时运行的错觉。</p><p>cpu通过时间片循环执行线程任务，当线程的cpu时间片用完后会保存当前任务状态，方便下次获取到cpu时间片的时候能继续执行，当下次分配时间片后执行到该线程时，会重新加载该线程的任务状态，而这个从保存任务状态到重新加载的过程就叫上下文换。</p><p>在进程A切换到进程B的过程中，先保存A进程的上下文，以便于等A恢复运行的时候，能够知道A进程的下一条指令是啥。然后将要运行的B进程的上下文恢复到寄存器中。这个过程被称为上下文切换。上下文切换开销在进程不多、切换不频繁的应用场景下问题不大。但是现在Linux操作系统被用到了高并发的网络程序后端服务器。在单机支持成千上万个用户请求的时候，这个开销就得拿出来说道说道了。因为用户进程在请求Redis、Mysql数据等网络IO阻塞掉的时候，或者在进程时间片到了，都会引发上下文切换。</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p><p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p><p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021-2-27-1.png" alt="2021-2-27-1"></p><h2 id="fork系统调用过程"><a href="#fork系统调用过程" class="headerlink" title="fork系统调用过程"></a>fork系统调用过程</h2><p>fork()系统调用用于创建新进程，新创建的进程为<strong>子进程</strong>，调用fork()并创建新进程的进程是<strong>父进程</strong>。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程</p><p>子进程创建后，系统会给子进程分配资源，然后把原来的进程的所有值都复制到新的子进程中，只有少数值与原来的进程的值不同；其实就是父进程的一份<strong>副本</strong>。但是子进程和父进程驻留在不同的内存空间上。这些内存空间具有相同的内容，并且一个进程执行的任何操作都不会影响其他进程，进程间彼此是数据隔离的。</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><p>进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p></li><li><p>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p></li><li><p>线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p></li><li><p>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</p></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程是多条线程共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小。</p><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><h2 id="线程切换时机"><a href="#线程切换时机" class="headerlink" title="线程切换时机"></a>线程切换时机</h2><ul><li>CPU时间片用完</li><li>垃圾回收</li><li>更高优先级线程运行</li><li>线程自己调用sleep，yield，wait，join，park，synchronized，lock</li></ul><h2 id="线程切换过程"><a href="#线程切换过程" class="headerlink" title="线程切换过程"></a>线程切换过程</h2><p>如果现在有两个并发的线程：外壳线程和hello线程。<br>　　开始只有外壳进程在运行，即等待命令行上的输入，当我们让他运行hello程序时，外壳通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。<br>　　操作系统保存外壳线程的上下文，创建一个新的hello线程及其上下文，然后将控制权传递给新的hello进程。<br>　　hello线程终止后，操作系统恢复外壳线程的上下文，并将控制权传回给他，外壳线程将继续等待下一个命令行输入。</p><h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><h3 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h3><ul><li><p>1：1实现</p></li><li><p>由内核完成线程切换</p></li><li><p>一般使用内核线程的高级接口-轻量级进程</p></li><li><p>即使其中某个轻量级进程在系统调用中被阻塞，也不会影响整个进程继续工作</p></li><li><p>缺点是轻量级进程要消耗一定的内核资源，线程操作需要系统调用</p></li><li><p>Java线程模型基于操作系统原生线程模型实现，即1：1线程模型</p></li><li><p>每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理</p><p>Java虚拟机的线程模型基于操作系统原生线程模型来实现，每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以Java虚拟机自己是不会去干涉线程调度的(可以设置线程优先级给操作系统提供调度建议)，全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p><p>操作系统支持怎样的线程模型，在很大程度上会影响上面的Java虚拟机的线程是怎样映射的。线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是完全透明的。</p></li></ul><h3 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h3><ul><li>1：N实现</li><li>完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在</li><li>完全由用户态完成，不需要切换到内核态</li><li>一般不支持用户线程</li></ul><h3 id="用户线程和轻量级进程混合实现"><a href="#用户线程和轻量级进程混合实现" class="headerlink" title="用户线程和轻量级进程混合实现"></a>用户线程和轻量级进程混合实现</h3><ul><li>N:M实现</li><li>用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发</li><li>操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁</li></ul><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="协同式"><a href="#协同式" class="headerlink" title="协同式"></a>协同式</h3><ul><li>执行时间由线程本身来控制，实现简单，切换操作对自己可知，没有线程同步问题</li><li>线程执行时间不可控制，如果坚持不让处理机，可能系统崩溃</li></ul><h3 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h3><ul><li>由系统分配执行时间，线程切换不受线程本身决定</li><li>线程执行时间可控</li><li>线程调度虽然是系统自动完成，但可以设置线程优先级来建议操作系统</li><li>线程优先级不稳定，因为java线程是被映射到系统的原生线程上来实现的，可能某些操作系统实际优先级与java的不能一一对应，优先级还可能被系统自行改变</li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p><p><strong>做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><h2 id="多线程优势与弊端"><a href="#多线程优势与弊端" class="headerlink" title="多线程优势与弊端"></a>多线程优势与弊端</h2><p>原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p><p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021_2_17_3.png" alt="2021_2_17_3"></p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>1、（中断／异常等触发）正向模式切换并压入PSW／PC 。 （Program Status Word 程序状态字。program counter 程序计数器。指向下一条要执行的指令）</p><p>2、保存被中断进程的现场信息。</p><p>3、处理具体中断、异常。</p><p>4、把被中断进程的系统堆栈指针SP值保存到PCB。（Stack Pointer 栈指针。Process Control Block 进程控制块。）</p><p>5、调整被中断进程的PCB信息，如进程状态）。</p><p>6、把被中断进程的PCB加入相关队列。</p><p>7、选择下一个占用CPU运行的进程。</p><p>8、修改被选中进程的PCB信息，如进程状态。</p><p>9、设置被选中进程的地址空间，恢复存储管理信息。</p><p>10、恢复被选中进程的SP值到处理器寄存器SP。</p><p>11、恢复被选中进程的现场信息进入处理器。</p><p>12、（中断返回指令触发）逆向模式转换并弹出PSW／PC。</p><h3 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h3><p>进程切换一定发生在中断／异常／系统调用处理过程中，常见的有以下情况：</p><p>1、阻塞式系统调用、虚拟地址异常。</p><p>导致被中断进程进入等待态。</p><p>2、时间片中断、I/O中断后发现更改优先级进程。</p><p>导致被中断进程进入就绪态。</p><p>3、终止用系统调用、不能继续执行的异常。</p><p>导致被中断进程进入终止态。</p><h3 id="进程上下文切换开销"><a href="#进程上下文切换开销" class="headerlink" title="进程上下文切换开销"></a>进程上下文切换开销</h3><p>一种是直接开销、一种是间接开销。</p><p>直接开销就是在切换时，cpu必须做的事情，包括：</p><ul><li><p>切换页表全局目录</p></li><li><p>切换内核态堆栈</p></li><li><p>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p></li><li><ul><li>ip(instruction pointer)：指向当前执行指令的下一条指令<pre><code>- bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址    - sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址    - cr3:页目录基址寄存器，保存页目录表的物理地址</code></pre></li></ul></li><li><p>刷新TLB</p></li><li><p>系统调度器的代码执行</p></li></ul><p>间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。</p><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="高级调度-作业调度"><a href="#高级调度-作业调度" class="headerlink" title="高级调度/作业调度"></a>高级调度/作业调度</h2><ul><li>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</li><li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。</li><li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li><li>无-&gt;创建态-&gt;就绪态</li></ul><h2 id="中级调度-内存调度"><a href="#中级调度-内存调度" class="headerlink" title="中级调度/内存调度"></a>中级调度/内存调度</h2><ul><li>决定将哪个处于挂起状态的进程重新调入内存。</li><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li><li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。提高内存利用率和系统吞吐量</li><li>暂时调到外存等待的进程状态为挂起状态。PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息被挂起的进程PCB会被放到的挂起队列中。</li><li>挂起态-&gt;就绪态</li></ul><h2 id="低级调度-进程调度"><a href="#低级调度-进程调度" class="headerlink" title="低级调度/进程调度"></a>低级调度/进程调度</h2><ul><li><p>按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p></li><li><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p></li><li><p>进程调度的频率很高，一般几十毫秒一次。</p></li><li><p>从内存调入CPU，从就绪态-&gt;运行态</p></li></ul><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="非交互式进程调度算法"><a href="#非交互式进程调度算法" class="headerlink" title="非交互式进程调度算法"></a>非交互式进程调度算法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>不关心“响应时间”，也并不区分任务的紧急程度</li><li>适合用于早期的批处理系统</li><li>法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li><li>对于用户来说，交互性很糟糕</li></ul><h3 id="先到先服务-FCFS"><a href="#先到先服务-FCFS" class="headerlink" title="先到先服务(FCFS)"></a>先到先服务(FCFS)</h3><ul><li>从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li><li>非抢占式的算法</li></ul><h3 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h3><ul><li>从就绪队列中选出⼀个估计运行时间最短的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>非抢占式</li><li>每次调度时选择当前已到达且运行时间最短的作业</li><li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li><li>对短作业有利，对长作业不利。</li><li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。</li><li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。当一个进程完成时也需要调度</li></ul><h3 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h3><ul><li>Highest Response Ratio Next</li><li>综合考虑作业/进程的等待时间和要求服务的时间</li><li>非抢占式</li><li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li><li>响应比=（等待时间+要求服务时间）/要求服务时间</li><li>只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li></ul><h2 id="交互式进程调度算法"><a href="#交互式进程调度算法" class="headerlink" title="交互式进程调度算法"></a>交互式进程调度算法</h2><h3 id="时间片轮转（RR，-Round-Robin）"><a href="#时间片轮转（RR，-Round-Robin）" class="headerlink" title="时间片轮转（RR， Round-Robin）"></a>时间片轮转（RR， Round-Robin）</h3><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li><li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li><li>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li></ul><h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><ul><li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度；当就绪队列发生改变时也需要检查是会发生抢占</li><li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li><li>若源源不断地有高优先级进程到来，则可能导致饥饿</li><li>具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ul><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li><li>对其他调度算法的折中权衡</li><li>UNIX 操作系统采取的便是这种调度算法。</li><li>抢占式的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li><li>对各类型进程相对公平（FCFS的优点）</li><li>每个新到达的进程都可以很快就得到响应（RR的优点）</li><li>短进程只用较少的时间就可完成(SPF优点)</li><li>不必实现估计进程的运行时间（避免用户作假）</li><li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</li><li>会导致饥饿</li></ul><h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</li><li>为了安全，一个进程不能直接访问另一个进程的地址空间</li><li>任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核</li><li>在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ol><li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系<strong>通常是指父子进程关系</strong>。把前一条命令的输出作为后一条命令的输入</li><li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列MessageQueue：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存SharedMemory：<strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>信号量Semaphore：信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，实现进程、线程的对临界区的同步及互斥访问。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li></ol><h2 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h2><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，<strong>操作系统内核</strong>专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种<strong>同步机制（如信号量）</strong>来达到进程间的同步及互斥。</li><li>操作系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制</li><li>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</li><li>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，因为把同一块物理内存的地址空间映射到不同进程的地址空间当中，那么不同的进程之间通信，通过直接修改地址空间当中的内存即可，该机制的实现只需要两次拷贝即可实现，不需要像其它的进程通信机制那样将数据从用户空间拷贝到内核，然后在从内核拷贝到用户空间，实行四次拷贝操作，因此使用共享内存通信比较高效。使用共享内存的话，需要对共享的进程对共享内存的访问进行同步，防止访问对于共享数据的破坏。</li></ul><p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p><p>采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，<strong>则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong></p><p><img src="https://images2015.cnblogs.com/blog/364303/201608/364303-20160829133915152-273836485.png" alt="img"></p><p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p><h2 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h2><ul><li>信号量是⼀个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。</li><li><strong>解决共享内存多进程竞争内存的问题</strong></li><li>信号量是一个计数器，可以用来控制多个线程对共享资源的访问。它不是用于交换大批数据，而用于多线程之间的同步。它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul><li>管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。</li><li>匿名管道是单向的，只能在有亲缘关系的进程间通信有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li>无名管道阻塞问题： 无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li><li>有名管道阻塞问题： 有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li><li>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</li><li>通信方式效率低下，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</li><li>管道不适合频繁通信的进程</li><li>各进程要互斥地访问管道</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li></ul><h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><ul><li>netstat -tulnp | grep 8080</li><li>把前一条命令的输出作为后一条命令的输入</li><li>如果两个进程要进行通信的话，就可以用这种管道来进行通信</li><li>这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道</li><li>这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。</li></ul><p><strong>特点</strong></p><ul><li>管道是半双工的，数据只能向一个方向流动需要双方通信时，需要建立起两个管道。</li><li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><p><strong>实质</strong></p><ul><li>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</li><li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li><li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li></ul><p><strong>局限</strong></p><ul><li>只支持单向数据流</li><li>只能用于具有亲缘关系的进程之间</li><li>没有名字</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）</li><li>管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</li></ul><h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><ul><li>它提供了一个路径名与之关联</li><li>有名管道的文件形式存在于文件系统中 ，这样， 即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信 ，因此，通过有名管道不相关的进程也能交换数据。</li><li>严格遵循先进先出(first in first out)，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 有名管道的名字存在于文件系统中，内容存放在内存中。</li></ul><pre class="line-numbers language-none"><code class="language-none">mkfifo  test #创建了一个名字为 test 的命名管道echo "this is a pipe" &gt; test   // 写数据//用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来//这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束cat &lt; test  // 读数据 test 里面的数据被读取出来了。上一条命令也执行结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h2><ul><li><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p></li><li><p>把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取</p></li><li><p>a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的</p></li><li><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p></li><li><p>存放在内核中，只有在内核重启(操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p></li><li><p>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p></li><li><p>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识.</p></li><li><p>消息队列允许一个或多个进程向它写入与读取消息</p></li><li><p>管道和消息队列的通信数据都是先进先出的原则。</p></li><li><p>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比FIFO更有优势。</p></li><li><p>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</p></li><li><p>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></li></ul><h2 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h2><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li><li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></li></ul><h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><ul><li>解决两个相隔几千里的进程能够进行通信</li><li>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</li><li>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li><li>特性由3个属性确定，它们分别是：域、端口号、协议类型。</li><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密，数据安全性强</li></ul><h1 id="线程间同步机制"><a href="#线程间同步机制" class="headerlink" title="线程间同步机制"></a>线程间同步机制</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p><strong>通过对多线程的串行化来访问公共资源或一段代码</strong>，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>采用互斥对象机制。 <strong>只有拥有互斥对象的线程才有访问公共资源的权限</strong>，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><p> 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以<strong>跨越进程使用</strong>。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>它允许多个线程在同一时刻访问同一资源，但是需要<strong>限制在同一时刻访问此资源的最大线程数目</strong> 。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p> <strong>通过通知操作的方式</strong>来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 </p><h1 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">do</span><span class="token punctuation">{</span>    <span class="token comment">//进入区 负责实现互斥的代码段 负责检查是否可进入临界区，可以则上锁</span>    <span class="token comment">//临界区 临界区是进程中访问临界资源的代码段</span>    <span class="token comment">//退出区 负责实现互斥的代码段 负责解锁</span>    <span class="token comment">//剩余区 做其他处理</span><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>称间接制约关系</li><li>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</li><li>把一个时间段内只允许一个进程使用的资源称为临界资源</li><li>对临界资源的互斥访问</li></ul><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><ul><li>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</li><li>哲学家进餐问题：每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源</li><li>当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么他们就会永远被阻塞</li></ul><h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li><li>不可剥夺条件：进程所获得的资源在未使用完之前， 不能由其他进程强行夺走 ，只能主动释放。</li><li>请求和保持条件：进程已经保持了至少一个资源 ，但又提出了新的资源请求 ，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链 ，链中每一个进程已获得的资源同时被下一个进程所请求。</li></ul><h2 id="死锁发生"><a href="#死锁发生" class="headerlink" title="死锁发生"></a>死锁发生</h2><ul><li>对不可剥夺资源的不合理分配，可能导致死锁</li><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><ul><li>把只能互斥使用的资源改造为允许共享使用</li><li>SPOOLing技术</li><li>并不是所有的资源都可以改造程可共享使用的资源</li></ul><h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ul><li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时，再重新申请。</li><li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</li></ul><p><strong>缺点</strong></p><ul><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保持和恢复状态的资源</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这种情况，就会导致进程饥饿</li></ul><h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul><li>采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源</li><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li></ul><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul><li>可采用顺序资源分配法</li><li>首先给系统种的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li><li>一个进程只有已占有小编号的资源时，才有资源申请更大编号的资源。按此规则，已有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会循环等待的现象。</li></ul><p><strong>缺点</strong></p><ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源消费</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h3><ul><li>用某种方法防止系统进入不安全状态，从而避免死锁</li><li>如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。如果有进程提前归还一些资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是考虑到最坏的情况。</li><li>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，系统未必发生死锁。但发生死锁移动是在不安全状态。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ul><li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li></ul><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>①检查此次申请是否超过了之前声明的最大需求数</li><li>②检查此时系统剩余的可用资源是否还能满足这次请求</li><li>③试探着分配，更改各数据结构，系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）</li><li>④用安全性算法检查此次分配是否会导致系统进入不安全状态。操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li></ul><h4 id="安全性算法步骤"><a href="#安全性算法步骤" class="headerlink" title="安全性算法步骤"></a>安全性算法步骤</h4><ul><li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li><li>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li><li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>长度为 m 的一维数组 Available 表示还有多少可用资源</li><li>n*m 矩阵 Max 表示各进程对资源的最大需求数</li><li>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源</li><li>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源</li><li>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</li></ul><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608435673_12.png" alt="img"></p><h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><ul><li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁</li><li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li></ul><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436005_13.png" alt="img"></p><ul><li>使用数据结构资源分配图来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li><li>如果系统剩余的可用资源数满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这些可能又会激活另外一些阻塞的己进程</li><li>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）</li><li>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li></ul><h4 id="检测死锁的算法"><a href="#检测死锁的算法" class="headerlink" title="检测死锁的算法"></a>检测死锁的算法</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436112_14.png" alt="img"></p><h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><ul><li>用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li><li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但是所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 中断 </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统回顾-操作系统概述</title>
      <link href="/2021/07/12/cao-zuo-xi-tong-gai-shu/"/>
      <url>/2021/07/12/cao-zuo-xi-tong-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><p>操作系统位于计算机的纯硬件之上，应用程序之下，作为它们之间衔接的部分。而用户使用计算机，直接使用的部分是安装在计算机上的应用程序。当然，用户可以直接对操作系统进行交互，比如设置系统的时间。</p><ol><li>操作系统负责管理协调硬件，软件等计算机资源的工作</li><li>为上层的应用程序、用户提供基础服务</li><li>操作系统是系统软件，而不是硬件</li></ol><h2 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h2><p>操作系统主要是按一定规则，协调管理硬件使用，同时因其为系统软件，为上层应用程序以及使用应用程序的用户提供服务，所以他还提供一些便捷的操作方式与图形化的操作界面。</p><p>硬件的管理主要可分为：</p><ol><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ol><p>提供给用户便捷使用的接口为：</p><ol><li>命令接口（cmd命令行，用户可以在这里通过命令的方式向计算机发起执行某种操作的请求，操作系统对命令进行解析处理，如果命令合法则执行）</li><li>程序接口（应用程序本身依赖于底层的硬件才可以被执行，用户可以通过操作系统提供的程序接口直接在应用层运行程序)</li><li>GUI（图形用户界面）(比如文件移动如果没有操作系统，要几条命令才能完成，但操作系统只需要拖拽就行)</li></ol><p>值得一提的是，命令接口还分联机命令接口和脱机命令接口：</p><p>联机：平常开cmd，用户说一句，系统执行一句</p><p>脱机：bat批处理操作，把需要执行的命令集成起来，让操作系统一次执行全部</p><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p>操作系统在按照一定规则实现其功能的过程中，不免有一些出现的比较多的思想，有一些可以概括为:</p><ul><li><p>并发——宏观上同时发生，微观上交替发生</p><p>(以程序来说的话，意思在用户看来，我双击了两个程序，当前CPU有两个程序都在执行中，但其实一个时间点CPU只是在处理一个程序中的指令，另一个只是在等待。)</p></li><li><p>并行——两个或多个事件同一时刻同时发生</p><p>（这是真的在一起执行，比如多核CPU的出现）</p></li><li><p>共享——系统资源共享</p></li><li><p>虚拟——把一个物理实体变成若干个逻辑上的对应物，实体是实际存在的，而虚拟是用户感受到的</p><ol><li><p>虚拟内存：比如一个GTA5想要运行需要4GB内存，而内存还有其他程序要用，那么根据一个程序运行前必须要放进内存，这个内存就必须要被虚拟的方式扩张。</p><p>如果按照以前的方式，一个作业必须要一次性全部装入内存（物理内存）后，才可以开始运行，这样就导致了大作业没法运行（内存不够)。且大量作业要求运行时，内存空间不够让所有程序都被容纳，导致并发度下降（可能CPU是空闲的，但是内存不够，就可惜）。</p><p>而且一旦作业的内容被装入内存，就会一直驻留再内存中，直到作业运行结束。事实上，在一个时间段内只需要有一部分数据被访问就行，如果一次性装入作业所有内容，则内存中很大一部分时间的很大一部分数据都是无用的，这就导致了内存空间被浪费。</p><p>虚拟内存技术的基础：离散内存分配，即进程的逻辑地址空间分散地存储在内存不连续的物理地址空间中，典型的技术有：分段、分页、段页式。</p><p>虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每个块被称作一页或页面。每一页有连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。</p><p>最开始被装入物理内存的内容，只是作业当前需要使用的数据和指令 ，其它的内容被暂时放在外存。</p><ul><li>当一个程序执行过程中，所访问的信息不在内存时，由操作系统负责将外存的所需信息调入内存，然后执行之前失败的程序。</li><li>如果内存空间不够，操作系统负责将物理内存中暂时用不到的内容换出到外存，这个“暂时用不到”一般基于LRU思想：最近最久未使用。其实就是把物理内存看作一个高速缓存来实现，只是其他的内容被逻辑映射了可以随时切换。</li></ul><p>这样，在操作系统管理下，一个作业的需要装入到内存的内容虽然很多，但是基于局部性原理，操作系统维护下只用了一小部分内存空间就完成了一个很大的内存使用。</p></li><li><p>虚拟文件：</p><p>虚拟文件系统的目的：将接口暴露给用户，屏蔽底层文件系统的差异性，它是对所有不同文件系统的抽象</p><p>它是一种用于网络环境的分布式文件系统，是允许和操作系统使用不同的文件系统实现的接口。虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，它对Linux的每个文件系统的所有细节进行抽象，使得不同的文件系统在Linux核心以及系统中运行的其他进程看来，都是相同的。严格说来，VFS并不是一种实际的文件系统。它只存在于内存中，不存在于任何外存空间。VFS在系统启动时建立，在系统关闭时消亡。</p><p>虚拟文件系统的功能： </p><ul><li>提供一致的文件和文件系统接口 </li><li>管理所有文件和文件系统关联的数据结构 </li><li>高效查询例程，遍历文件系统  - 与特定文件系统模块的交互</li><li>与特定文件系统模块的交互</li></ul></li><li><p>虚拟处理机：一个程序需要一个CPU来处理，那么多个程序能够同时（并发）运行，就用到了虚拟处理机技术，也叫时分复用技术。</p></li></ol></li><li><p>异步——进程并不是一次运行直接完成，而是运行一段停一段，而在宏观上看它们确实都在运行，这也是并发的一个会出现的情况。</p></li></ul><h2 id="OS的运行机制和体系结构"><a href="#OS的运行机制和体系结构" class="headerlink" title="OS的运行机制和体系结构"></a>OS的运行机制和体系结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ul><li>两种指令:特权（不允许用户程序使用），非特权</li><li>两种<strong>处理器</strong>状态，用户态和核心态，这两种态可以保证CPU来判断当前指令是否能执行。（用户态不能使用特权指令）</li><li>两种程序：内核程序，应用程序（根据上面的程序划分）</li></ul><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ul><li>时钟管理（实现计时间功能）</li><li>中断处理（处理中断的能力）</li><li>原语（有一些程序指令步骤是不能继续拆分的，操作系统需要规定这样的原语并保证执行正确）</li><li>资源管理——进程、存储器、设备（调度算法、内存管理方法、文件管理、获取外部设备分配资源等）</li></ul><h3 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h3><ul><li>大内核</li><li>微内核</li></ul><p>结构细分程度。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM &amp; volatile</title>
      <link href="/2021/07/06/jmm-volatile/"/>
      <url>/2021/07/06/jmm-volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM-amp-volatile"><a href="#JMM-amp-volatile" class="headerlink" title="JMM &amp; volatile"></a>JMM &amp; volatile</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p><strong>高速缓存</strong></p><p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。</p><p>由于程序运行过程中的临时数据都是放在主存（物理内存）中，当CPU执行过快，从内存（主存）中读取和写入数据的代价，比起指令执行就慢了不少。所以如果所有数据都要访问主存，会降低指令执行速度。</p><p>所以CPU中有了高速缓存，指令执行时会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><p>假设线程执行以下语句</p><pre class="line-numbers language-none"><code class="language-none">i = i + 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>单线程这样的操作不会有问题，但多线程呢？</p><p><strong>多线程情况</strong></p><p>多核CPU中，每条线程可能运行于不同CPU中，说明每个线程都有自己的高速缓存。</p><p>那假设同时两个线程执行i++，初始i为0，那我们希望的是两个线程执行之后i的值变为2：</p><p>假设下面这种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p>也就是最后多写了一个1进入主存。这就是<strong>缓存一致性</strong>问题，而这种被多个线程访问的变量为<strong>共享变量</strong>。</p><p><strong>解决办法</strong></p><p>为了解决缓存不一致的问题，通常有一下解决办法：</p><p>1）通过在总线加LOCK#锁的方式</p><p>2）通过缓存一致性协议</p><p>这两种方式都是硬件层面提供。</p><p><strong>总线加锁</strong></p><p>早期CPU是通过总线LOCK的形式解决。其实就是禁止总线其他CPU对共享资源的访问，当发现有指令操作共享主存数据时，就对总线加锁。</p><p>但是，上面的操作导致其他线程无法访问内存，效率极低。</p><p><strong>缓存一致性</strong></p><p>最出名的Intel MESI协议，保证缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的<strong>副本</strong>，会发出信号通知其他CPU将该变量的<strong>缓存行置为无效状态</strong>。</p><p>因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行无效，就会从内存重新读取。</p><h2 id="并发编程的三个概念"><a href="#并发编程的三个概念" class="headerlink" title="并发编程的三个概念"></a>并发编程的三个概念</h2><p>并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p><p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p><p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>　举个简单的例子，看下面这段代码：</p><pre class="line-numbers language-none"><code class="language-none">//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><pre class="line-numbers language-none"><code class="language-none">int i = 0;              boolean flag = false;i = 1;                //语句1  flag = true;          //语句2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么<strong>JVM在真正执行这段代码</strong>的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p><strong>指令重排序</strong></p><p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>也就是，CPU会按照更优秀的时间排序，把没有前置要求的任务先执行，但是这种重排序能保证单个线程的结果一致，如果多线程呢？</p><pre class="line-numbers language-none"><code class="language-none">//线程1:context = loadContext();   //语句1inited = true;             //语句2 //线程2:while(!inited ){  sleep()}doSomethingwithconfig(context);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行<code>doSomethingwithconfig(context)</code>方法，而此时context并没有被初始化，就会导致程序出错。</p><p> 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p><p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型-JMM"></a>Java内存模型-JMM</h2><p>Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p><strong>规定</strong></p><ul><li>规定所有的变量都是存在主存当中（类似于前面说的物理内存）</li><li>每个线程都有自己的工作内存（类似于前面的高速缓存）</li><li>线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。</li><li>并且每个线程不能访问其他线程的工作内存</li></ul><p><strong>举例</strong></p><p>假设在java种，执行下面的语句</p><pre class="line-numbers language-none"><code class="language-none">i = 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行线程的操作步骤如下：</p><ol><li>在自己工作线程对变量i所在缓存赋值</li><li>将值写入主存当中</li></ol><p>可以发现，并没有将10这个值直接写入主存。</p><p>java语言本身对原子性、可见性、有序性提供了什么保证？</p><h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p><p>请分析以下哪些操作是原子性操作：</p><pre class="line-numbers language-none"><code class="language-none">x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>答案是，只有第一个语句是原子性操作，我们来看每个操作具体做了什么，来理解什么是原子性操作：</p><p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p><p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p><p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p><p>所以上面4个语句只有语句1的操作具备原子性。</p><p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>对于可见性，Java提供了<strong>volatile关键字</strong>来保证可见性。</p><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>另外，通过通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，<strong>并且在释放锁之前会将对变量的修改刷新到主存</strong>当中。因此可以保证可见性。</p><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>在Java内存模型中，<strong>允许</strong>编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>在Java里面，可以通过volatile关键字来保证<strong>一定的</strong>“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p><strong>先天有序性</strong>：</p><p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，<strong>虚拟机</strong>可以随意地对它们进行重排序。</p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p><ul><li>程序次序规则：一段程序代码的执行在单个线程中看起来是有序的。这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”。这并不意味着写在前面的代码一定会先被CPU执行，因为虚拟机可能会对程序代码进行重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行结果一致，他想说的还是，当对数据无依赖的指令重排序之后，得到的程序执行结果依旧和不重排序一致。其实这个规则就是在说单个线程执行结果在重排序后依然正确，但不能保证的是多线程中执行的正确。</li><li>锁定规则：无论在单线程或多线程中，同一个锁如果处于被锁定的状态，则必须先对锁进行释放操作，然后再进行lock操作</li><li>一个变量的写操作先行发生于后面对这个变量的读操作。这句话的意思就是，当这个变量被读的时候能保证，写操作一定已经在之前完成过了，保证自己读的不是脏数据。假设一个线程要先写这个变量，然后另一个线程去读，那写操作一定先发生于读操作。</li><li>传递性，让两个线程的规律传播为多线程。</li></ul><h2 id="深入理解volatile"><a href="#深入理解volatile" class="headerlink" title="深入理解volatile"></a>深入理解volatile</h2><p>一旦一个共享变量（只能是变量），可以是类成员变量，可以是类静态成员变量。</p><h3 id="两层语义：可见性和禁重排"><a href="#两层语义：可见性和禁重排" class="headerlink" title="两层语义：可见性和禁重排"></a><strong>两层语义：可见性和禁重排</strong></h3><ol><li>保证不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</li><li>禁止进行指令重排序。</li></ol><p>第一个语义是怎么实现的呢？假设下面这段代码:</p><pre class="line-numbers language-none"><code class="language-none">//线程1boolean stop = false;while(!stop){    doSomething();} //线程2stop = true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个中断线程的标记方法，但是事实上，如果多线程执行时，有一种情况会让这段代码运行出错。</p><p>假设线程1执行了这段语句，将stop的值传到了自己的工作内存，这时线程2执行stop更改，但是还没来得及将更改刷新到主存，线程2就停了，这就会导致线程1的while循环会一直执行，没法更改。</p><p>但如果加了volatile修饰，情况就能解决：</p><ul><li>使用volatile关键字会强制将修改的值立即写入内存</li><li>使用volatile关键字的话，当线程2修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（因为线程2修改会将其强制修改），反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效</li><li>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取</li></ul><p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p><p>所以，线程1读取到的就是最新的正确的值。</p><h3 id="volatile的原子性"><a href="#volatile的原子性" class="headerlink" title="volatile的原子性"></a>volatile的原子性</h3><p>从上面知道volatile关键字保证了操作变量的可见性，但能不能保证原子性呢？</p><p>假设分析下面的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> inc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        inc<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                        test<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                 <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//保证前面的线程都执行完</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>inc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p><p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p><p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p><p>之前已经说过，自增操作是不具备原子性的，它包括读取变量的原始值，进行+1操作，写入工作内存。那么就是自增操作的三个子操作可能会分割唉执行，有可能导致下面着这种情况出现：</p><p>假如某个时刻变量inc的值为10，</p><p>线程1对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以读取的时候不会将线程2读取到的工作内存区inc的缓存无效，然后线程2去主存读取到了inc的值，然后+1，然后把11写入到工作内存和主存中。</p><p>这里线程1继续将刚刚读取到的inc值10，自增1，然后将11这个结果写入工作内存和主存。</p><p>出现的结果是，两个线程分别执行了依次自增操作，inc的最后结果仍然为11.</p><p>然而感觉还是有bug，之前说的是线程在修改值之后，会广播这个修改值给其他线程的工作内存，并让它们存储的这个被volatile的缓存无效化吗？为什么线程2明明改变了inc的值，但是没有把修改后的值广播到线程1的工作缓存，让线程1的正在使用的inc值无效呢？</p><p>这是因为，线程1在被阻塞前，已经读取了inc的值，这个读取无论是通过工作内存缓存区还是主存读取的，它都已经被读取过了，也就是虽然线程2在线程1更改inc的值之前把正确的值更改到了工作内存和主存中，但是线程1此时已经执行过了读取数据的操作，所以失去了读取到正确值的机会。</p><p>这也就是为什么volatile不能保证对变量的任何操作都是原子性的，因为这里的自增操作本身不是原子性的情况下，volatile修饰后依旧没有实现原子性。</p><h3 id="volatile的有序性"><a href="#volatile的有序性" class="headerlink" title="volatile的有序性"></a>volatile的有序性</h3><p>在前面提到的volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>volatile关键字禁止指令重排序有两层意思：</p><p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p>举个栗子:</p><pre class="line-numbers language-none"><code class="language-none">//x、y为非volatile变量//flag为volatile变量 x = 2;        //语句1y = 0;        //语句2flag = true;  //语句3x = 4;         //语句4y = -1;       //语句5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为flag变量为volatile变量，所以在指令重排序过程中，不会把3放在语句1、2前面，也不会将3放到语句4、5后面。其实也就是，以volatile操作指令为界限，它的前后指令顺序仍然可以重排序，但它们永远不会跨过volatile的指令。</p><h3 id="volatile原理和实现机制"><a href="#volatile原理和实现机制" class="headerlink" title="volatile原理和实现机制"></a>volatile原理和实现机制</h3><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p><p>　　下面这段话摘自《深入理解Java虚拟机》：</p><p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><h2 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><p>　　下面列举几个Java中使用volatile的几个场景。</p><p><strong>1.状态标记量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> inited <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//线程1:</span>context <span class="token operator">=</span> <span class="token function">loadContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  inited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>             <span class="token comment">//线程2:</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>inited <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">doSomethingwithconfig</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.double check</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>         <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token punctuation">}</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2021/06/16/duo-xian-cheng-ji-chu/"/>
      <url>/2021/06/16/duo-xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>有三种使用线程的办法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h3 id="实现Runnable的接口"><a href="#实现Runnable的接口" class="headerlink" title="实现Runnable的接口"></a>实现Runnable的接口</h3><p>需要实现接口中的run()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">MyRunnable</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token comment">//创建一个MyCallable的对象</span>    <span class="token class-name">MyCallable</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//封装返回值的类</span>    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>mc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建线程并启动</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">MyThread</span> mt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>既然可以实现接口和继承Thread类，到底怎么选？</strong></p><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>上面说到了start()方法和run()方法，包含都包含在线程启动中，它们各自代表的逻辑含义为：</p><h3 id="start："><a href="#start：" class="headerlink" title="start："></a>start：</h3><ul><li>启动新线程</li><li>处于就绪态（但没有进入CPU）</li><li>一旦得到CPU许可，就执行run()方法</li><li>不可重复执行start()方法，抛出异常：<code>IllegalThreadStateException</code>，说明当前线程状态不合法，可能是检测到了当前线程已经在就绪态。</li><li>Run方法运行结束时，该线程也终止</li></ul><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>run()方法只是这个线程类的具体执行逻辑方法，如果直接调用run方法，程序中依然只有这个包含run方法的一个主线程，程序还是顺序执行，而且要等run方法体执行完毕才能继续执行下面的代码，这样就没有实现并发。</p><p>调用start方法启动线程后，run方法只是这个启动的thread中的普通调用方法，还是在主线程里执行。由于start()方法启动线程时自动调用run方法，多个线程同时start时就会使多个thread处于就绪态，在这样根据cpu可实现并发。start方法启动线程自动调用run方法，是jvm内存机制规定的。</p><h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ul><li>使用interrupt()方法来通知，非强制中断</li><li>被中断的线程拥有如何响应中断的权利，必须等待线程处理完之后主动中止，所以不应该莽撞的使用stop方法</li><li>interrupt会被sleep的线程响应</li></ul><h3 id="run（）内没有sleep或wait方法时，停止线程"><a href="#run（）内没有sleep或wait方法时，停止线程" class="headerlink" title="run（）内没有sleep或wait方法时，停止线程"></a>run（）内没有sleep或wait方法时，停止线程</h3><p>如果不检测线程状态isInterrupted(),调用thread.interrupt() ; 没有任何影响。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span>， <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//需要检测是否被中断，并且响应</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">10000</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello + "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//调用不会清除打断标记的方法来判断是否被中断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被中断了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结束了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在线程sleep期间interrupt"><a href="#在线程sleep期间interrupt" class="headerlink" title="在线程sleep期间interrupt"></a>在线程sleep期间interrupt</h3><p>sleep期间中断时，调用isInterrupted()判断时，就算它真的中断了，但是调用这个方法后的终端标志就被清除了。但是通过try catch接收异常后，依然可以完成中断需求。</p><p>会抛出异常：InterruptedException（sleep interrupted）</p><p>会继续执行，不会中断：interrupt中断标记被清除，而且是循环，try-catch后会继续执行下一个循环</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span>， <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//需要检测是否被中断，并且响应</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello + "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//控制不住，因为调用后中断标志被清除了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果在sleep时中断，就会抛出该异常，所以就可以在catch中处理</span>            <span class="token comment">//该循环会继续工作，因为catch后就执行下一轮循环</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//sleep interrupted</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结束了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//控制interrupt时线程正在sleep</span>    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><h4 id="void-interrupt"><a href="#void-interrupt" class="headerlink" title="void interrupt()"></a>void interrupt()</h4><p>设置interrupted</p><p>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并且打断标记还是false。但是对于正常进程被打断打断标记是true</p><h4 id="static-boolean-interrupted"><a href="#static-boolean-interrupted" class="headerlink" title="static boolean interrupted()"></a>static boolean interrupted()</h4><p>目标对象为当前线程</p><p>清除当前线程的中断状态，并返回他之前的值</p><p>判断是否被打断，并且清除打断标记(设为false)</p><p>由于会清除当前线程的中断状态，如果调用他时返回true，那么除非你想屏蔽这个中断，否则必须对他进行处理。可以抛出InterruptedException，或再调用interrupt来恢复中断状态</p><h4 id="boolean-isInterrupted"><a href="#boolean-isInterrupted" class="headerlink" title="boolean isInterrupted()"></a>boolean isInterrupted()</h4><p>判断是否被打断，不会清除打断标记</p><p>返回目标线程的中断状态</p><h3 id="最佳方法的探究对比"><a href="#最佳方法的探究对比" class="headerlink" title="最佳方法的探究对比"></a>最佳方法的探究对比</h3><p>不应屏蔽中断请求</p><h4 id="优先选择：传递异常"><a href="#优先选择：传递异常" class="headerlink" title="优先选择：传递异常"></a>优先选择：传递异常</h4><p><strong>反面教材：在try-catch中处理</strong></p><p>这种情况因为try-catch调用了底层的方法，导致响应中断失败。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token comment">/*    catch了InterruptedException后优先选择在方法签名中抛出异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//这里调用下面的try-catch处理</span>                <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//如果子方法使用try-catch，则下面不会有效果</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//线程使用</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果用这样，则中断的时候会e.printStackTrace();但是会继续运行</span>        <span class="token comment">//因为该方法不是run()方法，是底层被run()调用的方法，就导致没能响应中断，run的while循环仍然执行</span>        <span class="token comment">//相当于把中断给吞掉了</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h4><p>没有使用try-catch，而是将异常直接抛出到方法签名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token comment">/*    catch了InterruptedException后优先选择在方法签名中抛出异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//run方法不能抛出异常，因为顶层的run方法没有异常，子类自然不能有</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存日志"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//线程使用</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//最佳是抛出异常到方法签名</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不想或者无法传递：恢复中断"><a href="#不想或者无法传递：恢复中断" class="headerlink" title="不想或者无法传递：恢复中断"></a>不想或者无法传递：恢复中断</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//因为重新设置了中断状态，所以是有效的</span>                <span class="token comment">//这里本来调用之后中断状态会消失，但是下面重新更新了中断状态，所以有效</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//线程使用</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwInMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//恢复设置中断状态，以便于在后续执行时，仍然能够检查到刚刚发生了中断</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="错误的停止方法"><a href="#错误的停止方法" class="headerlink" title="错误的停止方法"></a>错误的停止方法</h3><h3 id="被弃用的stop、resume方法等"><a href="#被弃用的stop、resume方法等" class="headerlink" title="被弃用的stop、resume方法等"></a>被弃用的stop、resume方法等</h3><p>会导致线程运行一半突然停止，没办法完成一个基本单位的操作</p><p>资源分配戛然而止，银行批量转账10个人，只转了8个人，很难排查错误</p><h3 id="用volatile设置boolean标记位"><a href="#用volatile设置boolean标记位" class="headerlink" title="用volatile设置boolean标记位"></a>用volatile设置boolean标记位</h3><p>这样陷入阻塞时，就不会有人去唤醒他，他就不会执行到判断volatile那个变量的标志位的代码，就会一直等待</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210616101653430.png" alt="image-20210616101653430"></p><ul><li>NEW：初始状态，线程被构建，但是没有调用start()</li><li>RUNNABLE：运行状态，将操作系统的就绪和运行状态统称为RUNNABLE；有可能正在运行，也有可能等待CPU资源</li><li>BLOCKED：阻塞状态，线程阻塞与锁；在程序等待进入同步区域时，将进入这种状态；在等待一个排它锁，该事件在另外一个线程放弃这个锁时发生；只有Synchronized修饰的，而且没有拿到锁，才是BLOCKED状态，其他锁不算</li><li>WAITING：无限期等待状态，当前线程需要等待其他线程通知或中断；没有设置Timeout的Object::wait()；没有设置Timeout的Thread::join()；LockSupport::park()</li><li>TIME_WAITING：超时等待状态，可以在指定的时间自行返回；Thread::sleep()；设置Timeout的Object::wait()；设置Timeout的Thread::join()；LockSupport::parkUntil()</li><li>TERMINATED：终止状态，当前线程已经执行完毕</li></ul><h2 id="Object相关方法"><a href="#Object相关方法" class="headerlink" title="Object相关方法"></a>Object相关方法</h2><ul><li><p>wait、notify、notifyAll定义在Object中，因为是锁级别的</p></li><li><p>wait需要在同步代码块内使用</p></li><li><p>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</p></li><li><p>wait(long timeout)让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p></li><li><p>因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁））</p></li><li><p>notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程</p></li><li><p>notify也要在synchronized使用，应该指定对象，t1.notify()，通知t1对象的等待池里的线程使一个线程进入锁定池，然后与锁定池中的线程争夺锁。那么为什么要在synchronized使用呢？ t1.notify()需要通知一个等待池中的线程，那么这时我们必须得获得t1的监视器（需要使用synchronized），才能对其操作，t1.notify()程序只是知道要对t1操作，但是是否可以操作与是否可以获得t1锁关联的监视器有关。</p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>使用wait必须先拥有monitor</li><li>使用notify只会唤醒一个，而且取决于JVM</li><li>任何对象都拥有这些方法</li></ul><h3 id="唤醒时机"><a href="#唤醒时机" class="headerlink" title="唤醒时机"></a>唤醒时机</h3><ul><li>notify()本线程</li><li>notifyAll()</li><li>wait(long timeout)超时时间达到</li><li>线程自身调用interrupt()</li></ul><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><ul><li>线程Id</li><li>线程名称</li><li>isDaemon(true代表是守护线程）<ul><li>是给用户线程提供服务的</li><li>默认情况下，Java进程会等待所有线程都运行结束，才会结束</li><li>守护进程，如果所有非守护进程结束，守护进程也都结束了(垃圾回收器)</li><li>如后台记录操作日志，监控内存，垃圾回收</li><li>thread1.setDaemon(true);</li></ul></li><li>priority（优先级）<ul><li>10个优先级，默认是5</li><li>优先级高度依赖于操作系统的优先级，Java映射过去的</li><li>优先级会被操作系统改变</li></ul></li></ul><h2 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><ul><li>让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程</li><li>可以调用interrupt()方法唤醒，但是会抛出异常：InterruptedException，并且会清除中断状态</li><li>不释放锁，规定时间后继续执行</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul><li>等待线程运行结束，可以控制线程的同步</li><li>因为新的线程加入了我们，所以我们要等他执行完再出发</li><li>main等待thread1执行完毕</li><li>源码调用wait()一直休眠，但每一个线程在执行完run()都会执行notifyAll()</li><li>此时主线程在waiting状态</li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><ul><li>提示线程调度器 让出当前线程对CPU的使用，具体要看操作系统实现</li><li>让当前的线程暂停，但是不阻塞，从运行状态变为就绪状态</li><li>让CPU重新调度，但是不能决定CPU</li><li>不会释放锁</li><li>为了稳定性，实际开发不使用，但是很多并发包使用</li></ul><h3 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h3><p>获取当前执行线程的引用</p><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210204082438815.png" alt="image-20210204082438815"></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>讨论的线程安全，以多个线程之间存在<strong>共享数据访问</strong>为前提</li><li>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果</li><li>代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无需关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用</li><li>通常将定义弱化，把调用这个对象的行为限定为单次调用</li><li>编写业务逻辑时不需要做额外的处理程序就能正常执行</li></ul><h3 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h3><ul><li>当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竟态条件。</li><li>最常见的就是“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步的动作。</li><li>竟态条件不是总会发生错误，还需要某种不恰当的执行时序</li><li>要避免竟态条件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><ul><li>只要一个不可变对象被正确的创建出来了（没有发生this引用逃逸），那其外部的可见状态让永远不会改变，永远不会看到他在多个线程之中处于不一致的状态。</li><li>不可变对象一定是线程安全的</li><li>不可变条件<ul><li>对象创建后其状态不能改变</li><li>对象的所有域都是final的</li><li>对象是正确创建的(this引用没有逸出)</li></ul></li><li>基本数据类型，只要定义时使用final修饰就可以保证不可变</li><li>对象<ul><li>需要对象自行保证其行为不会对其状态产生任何影响</li><li>如String对象实例，是典型的不可变对象</li><li>保证对象行为不影响自己状态，最简单的就是把对象里面的带有状态的变量声明为final</li><li>在构造函数后，就是不可变的</li><li>Integer不可变：private final int value;</li></ul></li></ul><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><ul><li>Java API标注是线程安全的，基本都不是绝对线程安全</li><li>例如Vector由synchronized修饰，保证了原子性，可见性，有序性。但复合操作仍然不是线程安全的，需要另外添加synchronized修饰</li></ul><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><ul><li>保证该对象单次操作是线程安全的</li><li>连续调用则需要使用额外的同步手段确保调用的正确性</li></ul><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><ul><li>通常意义上的线程不安全类</li><li>如HashMap</li></ul><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><ul><li>无法在多线程环境中并发使用代码</li><li>通常是有害的，应尽量避免</li></ul><h3 id="活跃性问题（死锁）"><a href="#活跃性问题（死锁）" class="headerlink" title="活跃性问题（死锁）"></a>活跃性问题（死锁）</h3><p>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</p><h3 id="在构造函数中未初始化完毕就this赋值"><a href="#在构造函数中未初始化完毕就this赋值" class="headerlink" title="在构造函数中未初始化完毕就this赋值"></a>在构造函数中未初始化完毕就this赋值</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Point</span> point<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span>， <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>point <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Point{x=1， y=0}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> x， y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x， <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token class-name">MainTest</span><span class="token punctuation">.</span>point <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Point{"</span> <span class="token operator">+</span>                <span class="token string">"x="</span> <span class="token operator">+</span> x <span class="token operator">+</span>                <span class="token string">"， y="</span> <span class="token operator">+</span> y <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合ConcurrentHashMap</title>
      <link href="/2021/06/09/concurrenthashmap/"/>
      <url>/2021/06/09/concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK1-7的ConcurrentHashMap"><a href="#JDK1-7的ConcurrentHashMap" class="headerlink" title="JDK1.7的ConcurrentHashMap"></a>JDK1.7的ConcurrentHashMap</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>背景</strong></p><ol><li><p>HashMap在高并发的环境下，执行put操作会导致HashMap的Entry链表形成环形数据结构，从而导致Entry的next节点始终不为空，因此产生死循环获取Entry。</p><p><strong>HashMap1.8的插入覆盖</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果没有hash碰撞则直接插入元素</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>if判断的是，当前元素的插入是否有hash冲突。那假设两个线程A、B都在进行put操作且hash之后数组下标相同。在时间片轮转的线程执行环境一下，A执行完if判断得到下标时间片耗尽，然后轮到B正常把key-value插入到了hashmap中。由于线程A已经判断过hash冲突了，轮到线程A执行的时候就直接把B刚刚插入进去的值给覆盖了，导致了线程不安全。</p></li><li><p>HashTable是线程安全的，当一个线程访问HashTable的同步方法时，其他线程如果也访问HashTable的同步方法，那么会进入阻塞或者轮询状态。这会带来不可避免的效率问题。</p><p>HashTable使用synchronized来保证线程的安全，但线程竞争激烈的时候。比如线程A在执行HashTable的put方法时，其他线程就只能阻塞或轮询，不仅不能使用put方法，甚至不能使用get方法。因为对于HashTable来说，synchronized覆盖整张表，而每次有线程操作就锁住了整张表，这导致每一次线程访问HashTable都去竞争一把锁，属实内卷。</p></li><li><p>那根据第二点说的，我们能不能每次让HashMap被访问的时候不锁住整张表，而是锁住表的一部分呢？这就是数据库也很常见的一个表级锁和行级锁的概念。在ConcurrentHashMap中，采用<strong>锁分段技术</strong>来完成。</p><p>假设容器里有多把锁，每个锁锁住表的一部分数据，就会大大减少锁竞争的情况。想要达成这个目的，需要下面的几步操作：</p><ol><li>数据分段存储</li><li>每段数据配一把锁，当线程访问一个段中的数据，其他线程也可以访问其他段的数据</li><li>ConcurrentHashMap在实现的时候，做到读取数据不加锁，写操作将锁粒度保持尽量小。</li></ol></li></ol><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>ConcurrentHashMap 由 Segment数组，和HashEntry数据结构组成。</li><li>Segment是一种可重入锁ReentrantLock, 在ConcurrentHashMap里，扮演锁的角色，HashEntry用来存储键值对</li><li>一个Segment数组和HashMap结构类似，是一个数组+链表的结构，一个Segment里，包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。</li><li>每个Segment锁住一个HashEntry数组里的元素（table[i]),相当于守护一个链表</li></ul><p>看图：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210608190621089.png" alt="image-20210608190621089"></p><p>可以分析上面的结构看出，ConcurrentHashMap定位一个元素的过程需要两次hash操作，第一次定位到Segment的数组下标，第二次hash定位到元素链表的头部。两次hash过程肯定要比普通的hashmap费时。</p><p>但好处是，写操作的时候可以只对元素所在的Segment加锁。那这样在最理想的情况下，ConcurrentHashMap可以同时支持Segment数量的写操作。</p><p><strong>那再来看看代码定义</strong></p><h3 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>     <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">//Segment中元素数量</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span> <span class="token comment">//对table大小造成影响的操作的数量</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment">//超过这个值就会对segment数组扩容，可以和capacity类比</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment">//链表数组，数组的每一个元素代表一个链表的头部</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span> <span class="token comment">//负载因子，确定threshold</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这里使用到了关键字<code>volatile</code>,它是一个比<code>sychronized</code>更加轻量级的同步操作，访问它的时候并不会执行加锁操作，但在加载到内存中的时候，会利用java内存屏障机制，禁止编译器优化导致的指令重排序。同时能保证可见性，即每次其更改都会让其他的线程马上发现。</li><li>table数组每一个元素是一个链表，链表的每个节点都是HashEntry类型</li></ul><h3 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>     <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>     <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>     <span class="token keyword">volatile</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>     <span class="token keyword">final</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashEntry的特点是，除了value，其他的变量都是final。这意味着不能从hash链的中间或尾部添加或删除节点，因为这要修改next引用，所有的节点修改都只能从头部开始。</p><p>对于put’操作，可以一律添加到链表头部。那如果是remove要删除链表中的某一个节点怎么办？这就需要将要删除的节点前面所有节点整个复制一遍，然后让最后一个节点指向要删除节点的下一个节点。</p><p>为了确保读操作能看到最新的值，value使用volatile避免了加锁。</p><h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><p>了解了基本实现思想，就结合源码看看每个操作具体是怎么实现的。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>                          <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">//三个初始化参数，initialCapacity,loadFactor,cocuutencyLevel,分别代表初始容量，负载因子，和Segment的数量。</span>    <span class="token comment">//需要注意的是，concurrencyLevel一经指定，不可改变，假设需要扩容，但是Segment数量也不会改变，只会增加Segment中链表的容量大小。</span>    <span class="token comment">//这样的好处是，扩容不需要对整个map做rehash，而只需要对每个Segment里面的元素做rehash就行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>loadFactor <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> concurrencyLevel <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>concurrencyLevel <span class="token operator">&gt;</span> MAX_SEGMENTS<span class="token punctuation">)</span>         concurrencyLevel <span class="token operator">=</span> MAX_SEGMENTS<span class="token punctuation">;</span>     <span class="token comment">// Find power-of-two sizes best matching arguments </span>    <span class="token keyword">int</span> sshift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> ssize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">//当ssize小于指定的Segment大小，将sshift+1，并ssize左移一位，这样保证了ssize永远是2的指数次方，sshift记录了左移的次数，也就是2的几次方</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ssize <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token operator">++</span>sshift<span class="token punctuation">;</span>         ssize <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment">//这两个变量之后有用，目前看不出有什么意义</span>    <span class="token comment">//segmentShift为32-n次方，而segmentMask为n次方 - 1</span>    segmentShift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> sshift<span class="token punctuation">;</span>     segmentMask <span class="token operator">=</span> ssize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">//确定segments的大小，并创建数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> <span class="token class-name">Segment</span><span class="token punctuation">.</span><span class="token function">newArray</span><span class="token punctuation">(</span>ssize<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>         initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>     <span class="token comment">// 根据initalCapacity,确定Segment的每个链表容量大小</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> initialCapacity <span class="token operator">/</span> ssize<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> ssize <span class="token operator">&lt;</span> initialCapacity<span class="token punctuation">)</span>         <span class="token operator">++</span>c<span class="token punctuation">;</span>     <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>         cap <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">//确定了每个Segment的元素大小为cap，并初始化</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cap<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token function">segmentFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，第一次hash得到的hash值，在segment又要根据hash值再hash一次。之所以要这样做，其实是为了减少hash冲突。</p><p>segmentFor操作，代表需要找到这个key在segment数组的那个槽中，看一下函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">segmentFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> segments<span class="token punctuation">[</span><span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;&gt;</span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此函数用了移位运算和与运算来获得数组下标，这两个参数是初始化的时候定义的。先将hash无符号右移segmentShift位，然后和segmentMask进行与操作。</p><p>其实，这就是Segment的数量是2的n次方，那根据元素的hash值的高n位就可以确定，元素到底是在哪一个Segment中。</p><p>确定了之后，自然要调用Segment的get方法，得到我们想要的value：</p><pre class="line-numbers language-none"><code class="language-none">1 V get(Object key, int hash) {  2     if (count != 0) { // read-volatile // ① 3         HashEntry&lt;K,V&gt; e = getFirst(hash);  4         while (e != null) {  5             if (e.hash == hash &amp;&amp; key.equals(e.key)) {  6                 V v = e.value;  7                 if (v != null) // ② 这里关键 8                     return v;  9                 return readValueUnderLock(e); // recheck 10             } 11             e = e.next; 12         } 13     } 14     return null; 15 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先对count进行判断，观察count是否等于0，count代表的意思是segment中元素数量有多少。</p><p>count是volatile的，保证了原子性和可见性，也就是对count的每一次更改（put、remove）等操作都会更新count的值，然后马上被其他线程发现。所以当竞争发生时，volatile可以保证写操作在读操作之前，所有读到的count值都不是脏数据。</p><p>然后，在第三行，调用了getFirst()来取得链表的头部</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>     <span class="token keyword">return</span> tab<span class="token punctuation">[</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样，这里的获取链表头部依然使用了hash和table的长度-1做与运算，得到segment下的数组下标。</p><p>得到链表头部之后，就开始对整个链表遍历，同样的比较方式，当key的hash值相等并equals之后，得到value值并存起来，那为什么要判断一次v不为空呢（之前的hashmap和linkedhashmap都是直接返回value的。）</p><p>那其实有可能的是，当前key值有可能得到的是一个其他线程正在put的key-value记录，然后value还没有写入的时候查找到了key。那么，当v不为空自然返回，为空时采用readValueUnderLock(e)，方法加锁取出value。</p><p>get方法没有使用锁来同步，只是判断获取的entry的value是否为null，为null采用加锁的方式再次获取。</p><p>这样的实现非常虽然看上去比较不严谨，但确实保证了同步的需求，我们来分析一下为什么。</p><ol><li><p>判断count!=0,因为count变量为0，说明segment中的entry个数为0，那就不用找了。那假设当前判断完了确实为0，其他线程正好在put这个key的entry对象，那岂不是没查到就很亏。而且两个线程的count肯定会不一致。</p></li><li><p>count 的定义是volatile，这里说了很多遍。正是因为这个机制，可以保证：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。所以，每次判断count变量的时候，即使其他线程改变了segment，也会体现出来。</p></li><li><p>get的第二步，通过hash获取到key所在segment的索引位置。找到了entry的时候，先把它单独获取出来，并在返回值的时候做了一个判断：<strong>if(v != null)</strong>,如果不为null才返回，为什么要加这么一个判断呢？</p><p>假设判断的时候，另一个线程新增/删除了entry，或者改变了entry的value，会如何？</p></li><li><p>而前面说过的HashEntry类中，除了value的值，其他全部都是final型变量，也就是只有value可以变，其他不可能被改变。</p></li><li><p>假设在get方法的代码①和②之间，另一个线程新增了一个entry，如果另一个线程新增的entry又恰好是要get的，会出现什么情况？</p></li><li><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210609192345793.png" alt="image-20210609192345793"></p></li><li><p>上图其实说明的就是put一个新的entry的过程，可以看出，他是让segment头指针指向新节点然后创建的时候就把新节点指向之前的头结点。这就是next指针为final的弊端，只能通过头插法。</p></li><li><p>newEntry对象是通过初始化来创建的，如果另一个线程在new这个entry的时候其他线程来get它，因为没有同步。就可能会出现当前线程得到的newEntry对象是一个，没有被完全构造好的对象引用。如果不同步锁，那鬼知道这个线程访问这个对象时，它是构造好还是没构造好，这就会导致一个线程得到了这个没构造好的引用。那我们为了判断到底他是不是一个引用，所以加了这个判断if（v!=null)，如果是null的，就说明是不完整对象，就用锁的方式再get一次。</p></li><li><p>假设在get方法的代码①和②之间，修改了entry值，由于volatile,保证了value值是修改之后的。</p></li><li><p>假设在get方法的代码①和②之间，另一个线程删除了其中一个entry。假设链表元素是e1-&gt; e2 -&gt; e3 -&gt; e4,我们删除e3这个entry，因为HashEntry中next不可变，所以无法将e2的next直接指向e4，而是要把e3之前的节点全复制一遍，然后让最后一个节点指向e3.next，也就是通过初始化的方式把next的值改了。</p></li><li><p>那如果我们顺着链表找e3，而删除e3的时候，e1的链表依然能找到e3，那就会得到这个本该被删除的e3节点，这该怎么解决？</p></li><li><p>其实我们在①处，判断了count变量，它保障了在①处，能看到其他线程修改后的segment中元素大小。他保障了①之前，我们当前线程知道其他线程改了元素，那如果过了①，就没法保证实时发现更改了。不过这也没任何关系，假设我们返回e3的时候，他被其他线程删除了，暴露出去的e3也不会对我们新的链表造成影响</p></li><li><p>这其实是一种乐观设计，设计者假设 ①之后到②之间 发生被其它线程增、删、改的操作可能性很小所以不采用同步设计，而是采用了事后（其它线程这期间也来操作，并且可能发生非安全事件）弥补的方式。而因为其他线程的“改”和“删”都不会对本来的存储数据造成影响（只可能会影响返回的值）。所以只对新增操作进行了安全检查。如果确认不安全事件，就加锁再次get。这样的判断减少了互斥锁对并发性能的影响。</p></li></ol><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>put操作中，put操作的前面也是确定Segment在哪的过程，然后关键是他具体怎么把这个新建的entry对象加入链表的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token number">2</span>     <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">3</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token number">4</span>         <span class="token keyword">int</span> c <span class="token operator">=</span> count<span class="token punctuation">;</span>  <span class="token number">5</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">++</span> <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span> <span class="token comment">// ensure capacity </span> <span class="token number">6</span>             <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">7</span>         <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>  <span class="token number">8</span>         <span class="token keyword">int</span> index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">9</span>         <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">10</span>         <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token number">11</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">!=</span> hash <span class="token operator">||</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">12</span>             e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token number">13</span>    <span class="token number">14</span>         <span class="token class-name">V</span> oldValue<span class="token punctuation">;</span> <span class="token number">15</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">16</span>             oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token number">17</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span> <span class="token number">18</span>                 e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token number">19</span>         <span class="token punctuation">}</span> <span class="token number">20</span>         <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token number">21</span>             oldValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token number">22</span>             <span class="token operator">++</span>modCount<span class="token punctuation">;</span> <span class="token number">23</span>             tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> first<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">24</span>             count <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// write-volatile </span><span class="token number">25</span>         <span class="token punctuation">}</span> <span class="token number">26</span>         <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span> <span class="token number">27</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token number">28</span>         <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">29</span>     <span class="token punctuation">}</span> <span class="token number">30</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>首先，在进入这个方法之后，就直接加锁了。也就是整个put操作都是加锁完成的。</li><li>然后，在加入之前会先判断加入之后的大小是否超过容量，如果超过的话会进行rehash()和扩容。</li><li>接下来确定链表头部的位置</li><li>遍历链表，找到相同key的元素，如果找到，就直接更新key的value，如果没有找到，则进入21行这里，生成新的hashentry并加到整个segment的头部，然后更新count操作。</li></ol><p>整个操作在不考虑多线程情况看起来是和hashmap的逻辑没有什么区别的。而这次是直接在方法初就加锁，这样是为了保证并发的安全。</p><p>修改数据是不能并发进行的，必须得有个判断是否超限的语句，来确保容量不足的时候能够rehash。接着是找是否存在同样的key节点，如果存在就直接替换，否则创建新节点添加到hash的头部。同时新建节点的操作需要修改modcount和count的值，修改count的值一定要放在最后一步。</p><p>put方法调用的rehash方法，也是利用了table的大小为2^n,而int index = hash &amp; (tab.length - 1)。说明segment数组的每一个元素其实都是一个hashtable。其实，因为加了锁，这个方法本身不难理解。</p><h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><p>remove操作其实很大一部分都和get/put操作一样，说白了都是要找到位置。</p><p>segment的remove方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token number">2</span>     <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">3</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token number">4</span>         <span class="token keyword">int</span> c <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token number">5</span>         <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>  <span class="token number">6</span>         <span class="token keyword">int</span> index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">7</span>         <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token number">8</span>         <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token number">9</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">!=</span> hash <span class="token operator">||</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">10</span>             e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token number">11</span>    <span class="token number">12</span>         <span class="token class-name">V</span> oldValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token number">13</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">14</span>             <span class="token class-name">V</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token number">15</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">16</span>                 oldValue <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token number">17</span>                 <span class="token comment">// All entries following removed node can stay </span><span class="token number">18</span>                 <span class="token comment">// in list, but all preceding ones need to be </span><span class="token number">19</span>                 <span class="token comment">// cloned. </span><span class="token number">20</span>                 <span class="token operator">++</span>modCount<span class="token punctuation">;</span> <span class="token number">21</span>                 <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> newFirst <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token number">22</span>                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> first<span class="token punctuation">;</span> p <span class="token operator">!=</span> e<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token number">23</span>                     newFirst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">,</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> <span class="token number">24</span>                                                   newFirst<span class="token punctuation">,</span> p<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">25</span>                 tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> newFirst<span class="token punctuation">;</span> <span class="token number">26</span>                 count <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// write-volatile </span><span class="token number">27</span>             <span class="token punctuation">}</span> <span class="token number">28</span>         <span class="token punctuation">}</span> <span class="token number">29</span>         <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span> <span class="token number">30</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token number">31</span>         <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">32</span>     <span class="token punctuation">}</span> <span class="token number">33</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>remove操作由于删除的节点前后next指针都不能修改，所以想要remove一个节点就必须通过初始化新节点的方式把next指针的值更改。</p><p>所以，找到删除的节点之后，就将这个节点前面的节点全部复制一遍，然后尾节点在创建的时候直接指向当前删除节点的下一个节点。e后面的节点可以不复制。</p><p>中间的for循环，是将定位之后的所有entry克隆并拼回前面去。</p><p>所以到底为什么要把他们设置成final呢，其实是因为不变性的访问不需要同步从而节省时间。</p><p>整个remove实现并不复杂，但需要注意的是：</p><ol><li>当删除节点存在，删除最后一步count-1，这必须是最后一步，否则读取操作可能看不到之前段所作的结构性修改</li><li>remove的最开始就将table赋值给一个局部变量tab，这是因为table是volatile变量，而下标访问，读写table[i]这样的代码开销很大，而且编译器还没法动语法顺序。所以把这个值先获取出来。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合LinkedHashMap</title>
      <link href="/2021/06/07/linkedhashmap/"/>
      <url>/2021/06/07/linkedhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p><strong>当我们希望有顺序的去存储key-value时，就需要LinkedHashMap了。</strong></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>LinkedHashMap继承HashMap，很多地方相似，可以与hashmap进行比较来学习</li><li>底层实现仍然是数组+链表/红黑树，由这些数据结构拼装而成。</li><li>在上面结构的基础上，<strong>增加</strong>了一条双向链表，使得通过上面的结构可以维护键值对的插入顺序。同时通过对链表进行相应操作，维护LRU顺序</li><li>每次增加新数据，或者访问（包括修改)数据时，会增加节点、或者调整链表的节点顺序。以决定迭代时输出的顺序。</li><li>LinkedHashMap并没有重写任何put方法。但是重写了构建新节点的newNode()方法。每次构建新节点时，将新节点链接在<strong>内部双向链表</strong>的尾部</li><li>在HashMap的插入删除等操作后，会调用<strong>钩子方法</strong>(afterNodeAccess， afterNodeInsertion， afterNodeRemoval)。而这些方法的实现就在LinkedHashMap中，这些方法的目的就是操作 before 和 after 指针。</li><li>通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代顺序。该迭代顺序可k以是<strong>插入顺序</strong>或者是<strong>访问顺序</strong>。</li><li>所以为什么叫LinkedHashMap，因为使用了HashMap的同时，用LinkedList完成了一些对元素顺序的规则体现。</li><li>LinkedHashMap虽然逻辑上看上去维护了一个链表和hashmap，但是其实链表只是加了指针来真正实现了结构，所以数据还是只有一份的。</li><li>循环双向链表头部，存放的是最久访问的节点或最先插入的节点、尾部为最近访问的或最近插入的节点。迭代器的遍历方向是从链表的头部开始到链表尾部结束、在链表尾部有一个空的header节点，该节点不存放key-value记录，是LinkedHashMap类的成员属性，循环双向链表的入口。</li></ul><p><strong>接下来主要从和HashMap不同的地方，来说LinkedHashMap的实现：</strong></p><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><h3 id="accessOrder"><a href="#accessOrder" class="headerlink" title="accessOrder"></a>accessOrder</h3><p>accessOrder == false(默认)，如果迭代遍历，遍历的顺序是插入节点的顺序。</p><p>accessOrder == true</p><ul><li>输出的顺序是按照访问节点的顺序。为true时，可以在这基础上构建一个LRUCache（LRU高速缓存）</li><li>在afterNodeAccess()函数中，会将当前被访问到的节点e，移动到内部的双向链表尾部</li><li>afterNodeAccess()函数中，操作会修改modCount。所以其实单纯的遍历一个LinkedHashMap，如果同时查询访问数据，会导致fail-fast，因为迭代的顺序已经改变了。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>LinkedHashMap重写 newNode, newTreeNode 方法，这两个方法其实是在插入时HashMap构建新节点时调用的，对于重写后的newNode:首先创建LinkedHashMap 的Entry节点，然后将其加入到before/ after链的尾部；</li><li>对于重写后的newTreeNode ，先是创建HashMap 的TreeNode节点， 因为其继承自LinkedHashMap # Entry，所以含有before / after指针，之后同样加入到链表尾部。</li></ul><h3 id="维护链表的方法"><a href="#维护链表的方法" class="headerlink" title="维护链表的方法"></a>维护链表的方法</h3><p>维护链表主要使用三个方法,在删除，插入，获取节点后</p><p>对链表进行维护。简单来说，这三个方法中执行双向链表的操作</p><ol><li><p>afterNodeRemoval</p><p>根据函数名，可以看出是在节点remove操作之后进行调用‘</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//在节点删除后，维护链表，传入删除的节点</span> <span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// unlink</span>     <span class="token comment">//p指向待删除元素，b指向前驱，a指向后驱</span>     <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>         <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>     <span class="token comment">//这里执行双向链表删除p节点操作，很简单。</span>     p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         head <span class="token operator">=</span> a<span class="token punctuation">;</span>     <span class="token keyword">else</span>         b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>         tail <span class="token operator">=</span> b<span class="token punctuation">;</span>     <span class="token keyword">else</span>         a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>afterNodeAccess</p><p>在节点被访问后，根据accessOrder参数，判断是否需要调整链表顺序。如果accessOrder为true，那么要将这个刚刚被访问的节点放在链表尾部。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// move node to last</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>    <span class="token comment">//如果accessOrder为false，什么都不做</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//p指向待删除元素，b执行前驱，a执行后驱</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        <span class="token comment">//这里执行双向链表删除操作</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token comment">//这里执行将p放到尾部</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">//保证并发读安全。</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>afterNodeInsertion</p><p>元素插入后，可能会删除最旧的、访问次数最少的元素，也就是头节点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// possibly remove eldest</span>       <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>       <span class="token comment">//removeEldestEntry(first)默认返回false，所以afterNodeInsertion这个方法其实并不会执行。但方法可以被子类改写，如果实现LRU cache，可以返回true。</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>           <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>      <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="原本的操作方法"><a href="#原本的操作方法" class="headerlink" title="原本的操作方法"></a>原本的操作方法</h3><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>LinkedHashMap没有重写put方法，执行put操作时，还是使用hashmap的put方法。那如何保证每次put操作的结点都被维护在链表尾部呢?原因就是HashMap的putVal方法，实际调用了上面说的，<strong>维护链表的方法</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//默认的传入的evict是true</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>             <span class="token comment">//如果e不为null，此时的e指向的就是在map中的那个插入点，所以这个时候来赋值。</span>             <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>             <span class="token comment">// onlyIfAbsent入口参数，为true，则不更新value（前面已说明）。</span>             <span class="token comment">//这个地方的主要作用主要控制如果map中已经有那个key了，是否需要需要更新值</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                 e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>             <span class="token comment">//这里其实是插入成功后执行的，获得的效果就是将e放到了链表结尾。</span>             <span class="token comment">//所以afterNodeInsertion方法就算什么都不做也可以。</span>             <span class="token comment">//但是如果accessOrder为false，那么我们新插入的节点，都不会进入链表了</span>             <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token comment">//fast-fail机制的实现，为了保证并发读安全。</span>     <span class="token operator">++</span>modCount<span class="token punctuation">;</span>     <span class="token comment">//容器中的键值对数自增，如果大于了阈值，开始扩容</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>         <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Remove操作"><a href="#Remove操作" class="headerlink" title="Remove操作"></a>Remove操作</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>                             <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>      <span class="token comment">//判断table是否为空，该key对应的桶是否为空</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>          <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              node <span class="token operator">=</span> p<span class="token punctuation">;</span>          <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                  node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">else</span> <span class="token punctuation">{</span>                  <span class="token keyword">do</span> <span class="token punctuation">{</span>                      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                          <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                           <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          node <span class="token operator">=</span> e<span class="token punctuation">;</span>                          <span class="token keyword">break</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span>                      p <span class="token operator">=</span> e<span class="token punctuation">;</span>                  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token comment">//到这里了其实node就已经指向了要删除的节点了</span>          <span class="token comment">//matchValue的作用是指现在是否需要值匹配。因为可能没有传入value，所以判断一下</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                               <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                  tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>              <span class="token keyword">else</span>                  p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>              <span class="token operator">++</span>modCount<span class="token punctuation">;</span>              <span class="token operator">--</span>size<span class="token punctuation">;</span>              <span class="token comment">//调用维护链表的操作</span>              <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> node<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Get操作"><a href="#Get操作" class="headerlink" title="Get操作"></a>Get操作</h4><p>调用父类的get方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> e<span class="token punctuation">;</span>        <span class="token comment">//调用父类的get方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>， key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//        当 accessOrder = true 时，即表示按照最近访问的迭代顺序，会将访问过的元素放在链表后面。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity， <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity， loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//默认是插入顺序</span>        <span class="token comment">//按照调用put方法插入的顺序进行排序的</span>        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//能指定accessOrder的值</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity，                         <span class="token keyword">float</span> loadFactor，                         <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity， loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><p>这里的迭代器就能体现我们苦苦维护的双向链表作用，每次访问的都是双向链表的顺序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//保证迭代顺序为双向链表的顺序</span><span class="token comment">//从链表头部开始遍历，那么如果插入a，b，c ，则输出还是a，b，c</span><span class="token comment">//如果是按照访问顺序，插入a，b，c后访问了a，则顺序变为了b，c，a 因为a被插入链表尾部</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashIterator</span> <span class="token punctuation">{</span>    <span class="token comment">//下一节点</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> next<span class="token punctuation">;</span>    <span class="token comment">//当前节点</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> current<span class="token punctuation">;</span>    <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>    <span class="token class-name">LinkedHashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//从双向链表的头元素开始遍历</span>        next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//记录当前modCount，以满足fail-fast</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token comment">//当前节点为null</span>        current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//nextNode() 就是迭代器里的next()方法 。</span>    <span class="token comment">//该方法的实现可以看出，迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出</span>    <span class="token keyword">final</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//按照双向链表而不是哈希数组的顺序遍历</span>        current <span class="token operator">=</span> e<span class="token punctuation">;</span>        next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除方法 最终还是调用了HashMap的removeNode方法</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> p <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">K</span> key <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>， key， <span class="token keyword">null</span>， <span class="token boolean">false</span>， <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//迭代器自己删除不算fail-fast</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> LinkedHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合HashMap</title>
      <link href="/2021/06/03/hashmap/"/>
      <url>/2021/06/03/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>HashMap是基于哈希表的Map接口的非同步实现</li><li>采用了（数组+链表+红黑树）的结构</li><li>HashMap的table默认初始容量为16（1&lt;&lt;4),默认负载因子为0.75f,容量总是2的n次方</li><li>16是一个经验值，既然一定要设置一个默认的2^n作为初始值，那么就需要在效率和内存使用上做一个权衡：太小了可能会频繁发生扩容，太大了浪费空间不划算</li></ul><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span>        <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span>， <span class="token class-name">Cloneable</span>， <span class="token class-name">Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，Entry类型本身定义了next字段，所以其实数组的每个元素都可能是存储键值的链表表头。</p><p>换言之，一个数组的元素位置被当成一个桶，一个桶存放一个链表。HashMap使用<strong>拉链法</strong>来解决冲突（不同Key值的hashcode()，再对hashmap长度取余之后得到同样的表中地址），同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><p>在JDK1.8后，桶中不仅仅会存储链表，如果链表过长，则链表结构转化为树，但链表本身的结构还存在（其实是保留了节点的next字段）。同样，当链表长度变少之后，会执行反树化。</p><p><strong>下面主要介绍hashmap的常用方法逻辑：</strong></p><h2 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h2><p>HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。这里需要着重理解</p><p>Hash的公式—&gt; <code>index = HashCode（Key） &amp; （Length - 1）</code>，每一个元素在进入hashmap的时候，想找到属于自己的数组索引位置，都会执行这个公式，正因为这是一个非常常见的操作，任何hashmap提供的api都需要先找到索引位置，所以如果能想办法降低这里的复杂度就会让hashmap的实现非常的优秀。</p><p>本来在理解hashmap的找索引下标方法时，是使用取余方式:<code>HashCode(key) % capacity</code>来获取的。当capacity为2的n次方时，前面的式子等价于<code>hash &amp; (capacity - 1) </code>,之所以这么做，是因为位运算的复杂度比取余快很多。</p><p>如果再细致一点，可以发现 <code>&amp; capacity - 1</code>这个方法等价于取余的原因，因为2的n次方的数据用位表示法只有有效最位为1，与运算的机制就是让其他非1的位置数据都不保留。而我们是想找到除了这个1位置的其他位数据。所以与它 减一 之后的二进制表示。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>创建一个新数组Entry，长度为之前数组的两倍</li><li>将所有旧数组的元素hash到新数组中</li><li>扩容后节点重 hash 只可能出现在“原索引位置” 与 “原索引 + oldCap（之前数组的容量大小） 位置”</li></ul><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><h3 id="计算下标"><a href="#计算下标" class="headerlink" title="计算下标"></a>计算下标</h3><ul><li>拿到 key 的 hashCode 值</li><li>将 hashCode 的高位参与运算，重新计算 hash 值<ul><li><code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>将 hashCode 的高 16 位与 hashCode 进行异或运算，主要是为了在 table 的 length 较小的时候，让高位也参与运算</li><li>通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li></ul></li><li>将计算出来的 hash 值与 (table.length - 1) 进行 &amp; 运算<ul><li>比取余操作更加有效率</li><li>因为x mod 2^n = x &amp; (2^n - 1)，而底层数组长度总是 2 的 n 次方，所以x mod table.length = x &amp; (table.length - 1)</li></ul></li></ul><h3 id="解决hash冲突"><a href="#解决hash冲突" class="headerlink" title="解决hash冲突"></a>解决hash冲突</h3><ul><li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li><li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li><li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li></ul><h2 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>计算key对应的hashcode</li><li>在entry数组较小时，能让高位参与hash的运算：<code>hash = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>如果table的值为空，说明table不存在，则进行初始化</li><li>如果计算出的数组索引位置：<code>i = (n - 1) &amp; hash</code> ，table[i]的值为空，说明这个桶没有存放过结点，则直接根据put的值新建节点赋予table[i]。</li><li> 如果table[i]不为空，看table[i]的首节点的key是否和put操作的key相同（这里的相同使用hashcode相同，且equals也为true来判断），相同则覆盖value，返回oldValue。</li><li>假设5的key不相等，则需要根据这个节点类型是TreeNode或者是链表来进行区分的判断。如果是红黑树节点，就用红黑树的put方法将值插入。如果是链表节点，则遍历链表，找到了value就覆盖，找到了链表尾部就新建node，并且根据链表长度和数组长度判断是否需要进行树化（默认链表长度 &gt; 8进行树化）。</li><li>插入成功后，需要查看是否需要扩容，modCount++,提供钩子方法。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">    /*    put相同键会替代    返回被替换的那个key的value或者null     */    public V put(K key， V value)    {        return putVal(hash(key)， key， value， false， true);    }    /*    onlyIfAbsent 当键相同时，不修改已存在的值    evict        仅在创建时为false    返回值 先前的值或null     */    final V putVal(int hash， K key， V value， boolean onlyIfAbsent，                   boolean evict)    {        Node&lt;K， V&gt;[] tab;        Node&lt;K， V&gt; p;//当前节点        int n， i;//        校验table是否为空或者length等于0，如果是则调用resize方法进行初始化        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        //如果当前索引位置值为空，直接新建节点放进去        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash， key， value， null);        else        {            Node&lt;K， V&gt; e;            K k;            //如果key相同，直接覆盖相同的值p            if (p.hash == hash &amp;&amp;                    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;                //如果是treenode，调用红黑树的put方法            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K， V&gt;) p).putTreeVal(this， tab， hash， key， value);            else            {                //binCount记录是否需要树化                for (int binCount = 0; ; ++binCount)                {                    //1.8采用了尾插法                    if ((e = p.next) == null)                    {                        p.next = newNode(hash， key， value， null);                        // 校验节点数是否超过TREEIFY_THRESHOLD，如果超过则调用treeifyBin方法将链表节点转为红黑树节点，                        // 减一是因为前面加了节点，但是binCount没更新                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab， hash);                        break;//此时break，e==null，不会进入 if (e != null)                    }                    //说明存在相同的key，要修改                    if (e.hash == hash &amp;&amp;                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                    //继续遍历下一个Node                }            }            //代表目标节点存在，使用传入的value覆盖该节点的value，并返回oldValue            if (e != null)            {                //说明要放的位置之前存在了元素                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);// 用于LinkedHashMap                return oldValue;            }        }        ++modCount;        //插入则size+1，而且大于threshold则需要扩容了        if (++size &gt; threshold)            resize();        // 用于LinkedHashMap的钩子函数        afterNodeInsertion(evict);        return null;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>获取对应的hash值</li><li>查看table本身是否存在，以及<code>tab[(n - 1) &amp; hash]</code>是否存在，这里为什么要使用这个表达式？</li><li>同样，得到了数组下标索引之后，和put一样，先判断索引下第一个节点的key的hash，equals是否都相同。若相同，则返回value。</li><li>如果是红黑树节点，调用红黑树节点方法搜索</li><li>如果是链表节点，遍历下拉链表搜索</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//key为null也可能是本身就是存储null的key</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>， key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash， <span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> first， e<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token class-name">K</span> k<span class="token punctuation">;</span>    <span class="token comment">//table不为空，table长度不为0，table相应的索引位置不为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//因为索引相同hash却不一定相同(多个hash映射到同一个槽)</span>        <span class="token comment">//hash相同并不一定是键相同，还要检查键是否相同或相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash， key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span>            <span class="token punctuation">{</span>                <span class="token comment">//执行链表节点的查找，向下遍历链表， 直至找到节点的key和入参的key相等时，返回该节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>， key<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h2><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ul><li>若扩容前table不为空，是正常的扩容，将数组长度变为原来的两倍</li><li>若老表的容量为0，老表的阈值大于0，这是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值。<ul><li>对应HashMap的两种初始化方法：new HashMap&lt;&gt;(32)</li></ul></li><li>老表的容量为0，老表的阈值为0，这种情况是没有传初始容量的方法创建空表，将阈值和容量设置为默认值，对应最常用的情况。<ul><li>即初始化的第三种情况 new HashMap()</li><li>默认容量16，负载因子0.75f</li></ul></li><li>Node&lt;K, V&gt;[] newTab =  (Node&lt;K， V&gt;[]) new Node[newCap];<ul><li>说明第一次调用resize()方法时，才进行了tab的初始化</li></ul></li><li>老表不为空，需遍历所有节点，将节点赋值给新表</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*初始化或扩容 */</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap， newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//扩容前的table不为空，即正常的扩容操作.将容量变成原来的两倍</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//阈值设为最大，但是不扩容</span>            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;</span><span class="token operator">&amp;</span>                oldCap <span class="token punctuation">&gt;</span></span><span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>        <span class="token comment">//容量和阈值都*2扩容</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果老表的容量为0， 老表的阈值大于0， 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值</span>    <span class="token comment">//对应前两种初始化HashMap的方法 例如new HashMap&lt;&gt;(32)</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment">//老表的容量为0， 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值</span>        <span class="token comment">//即初始化的第三种情况 new HashMap()</span>        <span class="token comment">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//对应前两种初始化方法，之前的threshold已经在初始化newCap时用过了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//计算新的负载因子</span>    <span class="token punctuation">{</span>        <span class="token comment">//很合理，假如new HashMap(32)，即ft=32*0.75</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> MAXIMUM_CAPACITY <span class="token operator">?</span>                <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token comment">//说明在第一次调用resize()方法时才进行了tab的初始化</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span>， <span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment">//如果老表不为空，则需遍历所有节点，将节点赋值给新表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> e<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">// 将索引值为j的老表头节点赋值给e</span>            <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 将老表的节点设置为空， 以便垃圾收集器回收空间</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//只有一个节点，直接散列</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment">//调用红黑树的重新散列</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span>， newTab， j， oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>                    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> loHead <span class="token operator">=</span> <span class="token keyword">null</span>， loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span>， hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span>                    <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                                             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                            <span class="token comment">//好强的代码，巧妙的构造了链表</span>                            <span class="token comment">//还是尾插法，尾插法就要维护一个头部(loHead)，以及当前指针(loTail)</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span>                        <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//散列开来</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span><span class="token comment">//放在新的位置</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol><li>首先判断当前数组是否为空，若为空直接返回null。</li><li>不为空，通过hash得到数组索引。</li><li>根据hash和equals判断哪个节点是删除的节点，首先判断头部节点，若头部节点相等，则查找命中，把结果暂存在临时节点p中</li><li>若头部不命中，判断当前头部节点的next节点是否存在。</li><li>若存在，如果是treenode，执行树的删除方法，返回被删除的节点</li><li>若是普通链表节点，遍历链表并查找需要被删除的节点，存入临时节点p中</li><li>根据临时节点p,通过判断key值相同或者是value值是否相同进行不同方式的删除。</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*matchValue 如果matchvalue这个参数为true，只有当value的值也相同，才会移除这个节点movable    如果为false，则在remove这个节点的同时，不会移动其他节点*/</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash， <span class="token class-name">Object</span> key， <span class="token class-name">Object</span> value，                            <span class="token keyword">boolean</span> matchValue， <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token comment">//table数组的复制</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>  <span class="token comment">//当前要被操作的节点</span>    <span class="token keyword">int</span> n， index<span class="token punctuation">;</span>      <span class="token comment">// 如果tab和table都不为空，tab长度大于0且高位运算hash不为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> node <span class="token operator">=</span> <span class="token keyword">null</span>， e<span class="token punctuation">;</span>        <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token class-name">V</span> v<span class="token punctuation">;</span>        <span class="token comment">//用hash和equals判断哪个节点是要被删除的节点，首先判断头部节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">//遍历链表（因为不管是treenode节点还是普通node节点，都有next字段，所以单纯的判断是否存在之后的节点，可以用next来避免代码的冗余）</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//如果是treenode的节点，得到treenode的节点值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash， key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//否则，遍历链表，找到要被删除的node节点</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">do</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                    <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//是否需要值相同才删除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//如果是treenode节点，使用treenode的删除方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span>， tab， movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token comment">//说明删除的是头元素</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token comment">//p是要删除元素的前一个元素(对应上面的else if)</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除后的钩子方法</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h2><p>暴力搜索所有节点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>    <span class="token class-name">V</span> v<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token class-name">K</span>， <span class="token class-name">V</span><span class="token operator">&gt;</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                        <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="JDK-1-7-和-1-8中的hashmap实现有什么区别"><a href="#JDK-1-7-和-1-8中的hashmap实现有什么区别" class="headerlink" title="JDK 1.7 和 1.8中的hashmap实现有什么区别"></a>JDK 1.7 和 1.8中的hashmap实现有什么区别</h3><p><strong>数据结构上</strong></p><ul><li>JDK1.8的单链表长度大于8时，会将链表转换为红黑树，以减少搜索时间</li></ul><p><strong>插入数据方式上</strong></p><ul><li>JDK1.7采用头插法新增节点，插入元素。在<strong>多线程情况</strong>下会导致环型链表的出现，<strong>扩容</strong>的时候导致死循环。死循环的主要诱因是，扩容后链表的节点顺序反掉</li><li>JDK1.8使用尾插法插入元素（直接插入到链表尾部/红黑树），解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ul><h3 id="JDK1-7的死循环"><a href="#JDK1-7的死循环" class="headerlink" title="JDK1.7的死循环"></a>JDK1.7的死循环</h3><ul><li>扩容操作中，把旧表中所有Node重新计算索引下标并散列到新表对应索引处(采用头插法)</li><li>把新表的引用赋值给table</li></ul><p>首先会导致链表反转：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210603155945969.png" alt="image-20210603155945969"></p><p>如果线程1、线程2同时操作，线程2执行到e = A、next = B时切换到线程1，线程1执行完resize导致链表反转成C-&gt;B-&gt;A-&gt;null。</p><p>线程2继续执行以下代码，则产生了死循环：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>e <span class="token operator">=</span> next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="HashMap的线程安全问题"><a href="#HashMap的线程安全问题" class="headerlink" title="HashMap的线程安全问题"></a>HashMap的线程安全问题</h3><p>从大神的博客看到的，举个栗子，假设两个线程同时进行put操作，在同时进入下面的语句时，Node节点会被后访问的节点覆盖。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="为啥链表长了要转红黑树"><a href="#为啥链表长了要转红黑树" class="headerlink" title="为啥链表长了要转红黑树"></a>为啥链表长了要转红黑树</h3><p>链表不够优秀的地方在于查找复杂度是顺序遍历，最差情况下是o(n),算法分析的理论是，如果n非常大，就要通过操作来让复杂度降维。这里如果将n非常大的情况下转化为红黑树，那么查找复杂度就降为o(logn)，就可以接受了。</p><p><strong>那为什么把这个链表长度的阈值设为8呢</strong></p><p>理想情况下，如果使用hash码进行索引的获取填入hashmap，元素们的位置（在桶中）的频率符合泊松分布。按照泊松分布的计算公式计算出桶中元素个数和概率的对照表，链表中元素个数为 8 时的概率非常小。</p><h3 id="默认的负载因子0-75？"><a href="#默认的负载因子0-75？" class="headerlink" title="默认的负载因子0.75？"></a>默认的负载因子0.75？</h3><p>就理解成，经过大量数据实验演算，发现当0.75的时候。在时间和空间成本上提供了很好的折衷，是对空间和时间效率的一个平衡选择。较高的值会降低空间开销，但提高查找成本。较低的值浪费空间。</p>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合LinkedList</title>
      <link href="/2021/05/16/linkedlist/"/>
      <url>/2021/05/16/linkedlist/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>基于双向链表实现，使用Node存储链表结点信息</li><li>每个链表都存储了first和last指针</li><li>不支持随机访问，但插入删除效率很高</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>允许null值</li><li>如果寻找索引，先判断从头找快，还是从尾找快</li><li>存储元素的结点需要额外的空间存储前驱和后继的引用</li></ul><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><strong>extends</strong> :</p><h3 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h3><ul><li>只支持按次序访问，提供了一套基于顺序访问的接口</li><li>通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口</li><li>public abstract ListIterator<e> listIterator(int index);</e></li></ul><p><strong>implements</strong>:</p><h3 id="List-lt-E-gt"><a href="#List-lt-E-gt" class="headerlink" title="List< E >"></a>List&lt; E &gt;</h3><ul><li>接口封装了一系列对序列操作和获取信息的方法</li><li>如size()，iterator()等</li><li>此List类继承Collection即根类</li></ul><h3 id="Deque-lt-E-gt"><a href="#Deque-lt-E-gt" class="headerlink" title="Deque< E >"></a>Deque&lt; E &gt;</h3><ul><li>Deque继承Queue，Queue继承Collection类，是基础的队列，有基本的功能实现</li><li>Deque是双向队列，是Queue接口的子接口，指队列两端的元素既能入队也能出队。</li><li>接口中封装了对于双向队列操作的功能方法</li></ul><h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>要重写<code>clone()</code>则必须实现<code>Cloneable</code>的接口,否则会报<code>CloneNotSupportedException </code>异常</p><p><code>Cloneable </code>接口为空,只是个合法调用 <code>clone</code>方法的标识</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable接口也为空,只是个合法调用方法的标识目的是实现序列化:可以将一个对象的转换成字节流,写成文件,需要的时候可以从流中再次读取(反序列化)。实现序列化之后的对象,可以通过IO操作进行读写</p><h2 id="源码注释阅读"><a href="#源码注释阅读" class="headerlink" title="源码注释阅读"></a>源码注释阅读</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 指向第一个结点的指针     */</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>    <span class="token comment">/**     * 指向最后一个结点的指针     * 不变量（不指定的默认值）     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */</span>    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>    <span class="token comment">/**     * Constructs an empty list.     */</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 构造一个包含指定集合元素的列表     * 返回的顺序和集合类中的iterator顺序一致     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection's     * iterator.     *     *      * @param  c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */</span>    <span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 链表首部添加一个新结点     * 逻辑：     * 用一个引用f指向(old)first     * 新增一个结点，结点值为新值     * first的引用变为引用newNode     * 此时判断oldFirst是否为空， 如果为空说明该元素为第一个元素，直接让last也为newNode     * 队列大小+1，队列操作次数+1     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 尾部添加一个结点     * 同样，让一个引用指向旧结点     * 创建新节点，更改原引用     * 若旧为空，说明是第一个结点，first也为此节点     * Links e as last element.     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Inserts element e before non-null Node succ.     * 插入结点在某个结点之前     * 创建引用为插入结点位置之前的结点     * 创建新节点并更改引用     * 如果旧引用为空，说明该插入结点无前结点，即该结点为第一个结点。     * 否则，让就引用结点next指向新插入的结点     */</span>    <span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// assert succ != null;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>        succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Unlinks non-null first node f.     * 会保证传入的f都是first     */</span>    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// assert f == first &amp;&amp; f != null;</span>        <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        f<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Unlinks non-null last node l.     * 删除最后的结点     * 获取元素值，和前驱结点引用     * 让元素值和prev引用为空     * 如果旧prev也为空，说明该结点为链表最后一个结点，first也为空     * 否则，只需要让前驱结点的next指向空     */</span>    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// assert l == last &amp;&amp; l != null;</span>        <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev <span class="token operator">=</span> l<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        l<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Unlinks non-null node x.     */</span>    <span class="token class-name">E</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// assert x != null;</span>        <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns the first element in this list.     *     * @return the first element in this list     * @throws NoSuchElementException if this list is empty     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns the last element in this list.     *     * @return the last element in this list     * @throws NoSuchElementException if this list is empty     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes and returns the first element from this list.     *     * @return the first element from this list     * @throws NoSuchElementException if this list is empty     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes and returns the last element from this list.     *     * @return the last element from this list     * @throws NoSuchElementException if this list is empty     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Inserts the specified element at the beginning of this list.     *     * @param e the element to add     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Appends the specified element to the end of this list.     *     * &lt;p&gt;This method is equivalent to {@link #add}.     *     * @param e the element to add     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns {@code true} if this list contains the specified element.     * More formally, returns {@code true} if and only if this list contains     * at least one element {@code e} such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.     *     * @param o element whose presence in this list is to be tested     * @return {@code true} if this list contains the specified element     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns the number of elements in this list.     *     * @return the number of elements in this list     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Appends the specified element to the end of this list.     *     * &lt;p&gt;This method is equivalent to {@link #addLast}.     *     * @param e element to be appended to this list     * @return {@code true} (as specified by {@link Collection#add})     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes the first occurrence of the specified element from this list,     * if it is present.  If this list does not contain the element, it is     * unchanged.  More formally, removes the element with the lowest index     * {@code i} such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;     * (if such an element exists).  Returns {@code true} if this list     * contained the specified element (or equivalently, if this list     * changed as a result of the call).     *     * @param o element to be removed from this list, if present     * @return {@code true} if this list contained the specified element     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Appends all of the elements in the specified collection to the end of     * this list, in the order that they are returned by the specified     * collection's iterator.  The behavior of this operation is undefined if     * the specified collection is modified while the operation is in     * progress.  (Note that this will occur if the specified collection is     * this list, and it's nonempty.)     *     * @param c collection containing elements to be added to this list     * @return {@code true} if this list changed as a result of the call     * @throws NullPointerException if the specified collection is null     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">addAll</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Inserts all of the elements in the specified collection into this     * list, starting at the specified position.  Shifts the element     * currently at that position (if any) and any subsequent elements to     * the right (increases their indices).  The new elements will appear     * in the list in the order that they are returned by the     * specified collection's iterator.     *     * @param index index at which to insert the first element     *              from the specified collection     * @param c collection containing elements to be added to this list     * @return {@code true} if this list changed as a result of the call     * @throws IndexOutOfBoundsException {@inheritDoc}     * @throws NullPointerException if the specified collection is null     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numNew <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> pred<span class="token punctuation">,</span> succ<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            pred <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> <span class="token class-name">E</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            pred <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span>            succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes all of the elements from this list.     * The list will be empty after this call returns.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Clearing all of the links between nodes is "unnecessary", but:</span>        <span class="token comment">// - helps a generational GC if the discarded nodes inhabit</span>        <span class="token comment">//   more than one generation</span>        <span class="token comment">// - is sure to free memory even if there is a reachable Iterator</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        first <span class="token operator">=</span> last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Positional Access Operations</span>    <span class="token comment">/**     * Returns the element at the specified position in this list.     *     * @param index index of the element to return     * @return the element at the specified position in this list     * @throws IndexOutOfBoundsException {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Replaces the element at the specified position in this list with the     * specified element.     *     * @param index index of the element to replace     * @param element element to be stored at the specified position     * @return the element previously at the specified position     * @throws IndexOutOfBoundsException {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">E</span> oldVal <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Inserts the specified element at the specified position in this list.     * Shifts the element currently at that position (if any) and any     * subsequent elements to the right (adds one to their indices).     *     * @param index index at which the specified element is to be inserted     * @param element element to be inserted     * @throws IndexOutOfBoundsException {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes the element at the specified position in this list.  Shifts any     * subsequent elements to the left (subtracts one from their indices).     * Returns the element that was removed from the list.     *     * @param index the index of the element to be removed     * @return the element previously at the specified position     * @throws IndexOutOfBoundsException {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Tells if the argument is the index of an existing element.     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isElementIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Tells if the argument is the index of a valid position for an     * iterator or an add operation.     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPositionIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Constructs an IndexOutOfBoundsException detail message.     * Of the many possible refactorings of the error handling code,     * this "outlining" performs best with both server and client VMs.     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">", Size: "</span><span class="token operator">+</span>size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkElementIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns the (non-null) Node at the specified element index.     */</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// assert isElementIndex(index);</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// Search Operations</span>    <span class="token comment">/**     * Returns the index of the first occurrence of the specified element     * in this list, or -1 if this list does not contain the element.     * More formally, returns the lowest index {@code i} such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,     * or -1 if there is no such index.     *     * @param o element to search for     * @return the index of the first occurrence of the specified element in     *         this list, or -1 if this list does not contain the element     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns the index of the last occurrence of the specified element     * in this list, or -1 if this list does not contain the element.     * More formally, returns the highest index {@code i} such that     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,     * or -1 if there is no such index.     *     * @param o element to search for     * @return the index of the last occurrence of the specified element in     *         this list, or -1 if this list does not contain the element     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Queue operations.</span>    <span class="token comment">/**     * Retrieves, but does not remove, the head (first element) of this list.     *     * @return the head of this list, or {@code null} if this list is empty     * @since 1.5     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves, but does not remove, the head (first element) of this list.     *     * @return the head of this list     * @throws NoSuchElementException if this list is empty     * @since 1.5     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves and removes the head (first element) of this list.     *     * @return the head of this list, or {@code null} if this list is empty     * @since 1.5     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves and removes the head (first element) of this list.     *     * @return the head of this list     * @throws NoSuchElementException if this list is empty     * @since 1.5     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Adds the specified element as the tail (last element) of this list.     *     * @param e the element to add     * @return {@code true} (as specified by {@link Queue#offer})     * @since 1.5     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Deque operations</span>    <span class="token comment">/**     * Inserts the specified element at the front of this list.     *     * @param e the element to insert     * @return {@code true} (as specified by {@link Deque#offerFirst})     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offerFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Inserts the specified element at the end of this list.     *     * @param e the element to insert     * @return {@code true} (as specified by {@link Deque#offerLast})     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves, but does not remove, the first element of this list,     * or returns {@code null} if this list is empty.     *     * @return the first element of this list, or {@code null}     *         if this list is empty     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves, but does not remove, the last element of this list,     * or returns {@code null} if this list is empty.     *     * @return the last element of this list, or {@code null}     *         if this list is empty     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves and removes the first element of this list,     * or returns {@code null} if this list is empty.     *     * @return the first element of this list, or {@code null} if     *     this list is empty     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Retrieves and removes the last element of this list,     * or returns {@code null} if this list is empty.     *     * @return the last element of this list, or {@code null} if     *     this list is empty     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Pushes an element onto the stack represented by this list.  In other     * words, inserts the element at the front of this list.     *     * &lt;p&gt;This method is equivalent to {@link #addFirst}.     *     * @param e the element to push     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Pops an element from the stack represented by this list.  In other     * words, removes and returns the first element of this list.     *     * &lt;p&gt;This method is equivalent to {@link #removeFirst()}.     *     * @return the element at the front of this list (which is the top     *         of the stack represented by this list)     * @throws NoSuchElementException if this list is empty     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes the first occurrence of the specified element in this     * list (when traversing the list from head to tail).  If the list     * does not contain the element, it is unchanged.     *     * @param o element to be removed from this list, if present     * @return {@code true} if the list contained the specified element     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeFirstOccurrence</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Removes the last occurrence of the specified element in this     * list (when traversing the list from head to tail).  If the list     * does not contain the element, it is unchanged.     *     * @param o element to be removed from this list, if present     * @return {@code true} if the list contained the specified element     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeLastOccurrence</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns a list-iterator of the elements in this list (in proper     * sequence), starting at the specified position in the list.     * Obeys the general contract of {@code List.listIterator(int)}.&lt;p&gt;     *     * The list-iterator is &lt;i&gt;fail-fast&lt;/i&gt;: if the list is structurally     * modified at any time after the Iterator is created, in any way except     * through the list-iterator's own {@code remove} or {@code add}     * methods, the list-iterator will throw a     * {@code ConcurrentModificationException}.  Thus, in the face of     * concurrent modification, the iterator fails quickly and cleanly, rather     * than risking arbitrary, non-deterministic behavior at an undetermined     * time in the future.     *     * @param index index of the first element to be returned from the     *              list-iterator (by a call to {@code next})     * @return a ListIterator of the elements in this list (in proper     *         sequence), starting at the specified position in the list     * @throws IndexOutOfBoundsException {@inheritDoc}     * @see List#listIterator(int)     */</span>    <span class="token keyword">public</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lastReturned<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token class-name">ListItr</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// assert isPositionIndex(index);</span>            next <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            nextIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>            next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextIndex <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextIndex<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">previousIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>                next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>            <span class="token keyword">else</span>                nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lastReturned<span class="token punctuation">.</span>item <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">linkBefore</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>            nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>            expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>                action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>                next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token class-name">E</span> item<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DescendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Adapter to provide descending iterators via ListItr.previous     */</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">DescendingIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ListItr</span> itr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> itr<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> itr<span class="token punctuation">.</span><span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            itr<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">superClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns a shallow copy of this {@code LinkedList}. (The elements     * themselves are not cloned.)     *     * @return a shallow copy of this {@code LinkedList} instance     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> clone <span class="token operator">=</span> <span class="token function">superClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Put clone into "virgin" state</span>        clone<span class="token punctuation">.</span>first <span class="token operator">=</span> clone<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        clone<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        clone<span class="token punctuation">.</span>modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// Initialize clone with our elements</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            clone<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> clone<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns an array containing all of the elements in this list     * in proper sequence (from first to last element).     *     * &lt;p&gt;The returned array will be "safe" in that no references to it are     * maintained by this list.  (In other words, this method must allocate     * a new array).  The caller is thus free to modify the returned array.     *     * &lt;p&gt;This method acts as bridge between array-based and collection-based     * APIs.     *     * @return an array containing all of the elements in this list     *         in proper sequence     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns an array containing all of the elements in this list in     * proper sequence (from first to last element); the runtime type of     * the returned array is that of the specified array.  If the list fits     * in the specified array, it is returned therein.  Otherwise, a new     * array is allocated with the runtime type of the specified array and     * the size of this list.     *     * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,     * the array has more elements than the list), the element in the array     * immediately following the end of the list is set to {@code null}.     * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if     * the caller knows that the list does not contain any null elements.)     *     * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between     * array-based and collection-based APIs.  Further, this method allows     * precise control over the runtime type of the output array, and may,     * under certain circumstances, be used to save allocation costs.     *     * &lt;p&gt;Suppose {@code x} is a list known to contain only strings.     * The following code can be used to dump the list into a newly     * allocated array of {@code String}:     *     * &lt;pre&gt;     *     String[] y = x.toArray(new String[0]);&lt;/pre&gt;     *     * Note that {@code toArray(new Object[0])} is identical in function to     * {@code toArray()}.     *     * @param a the array into which the elements of the list are to     *          be stored, if it is big enough; otherwise, a new array of the     *          same runtime type is allocated for this purpose.     * @return an array containing the elements of the list     * @throws ArrayStoreException if the runtime type of the specified array     *         is not a supertype of the runtime type of every element in     *         this list     * @throws NullPointerException if the specified array is null     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>            a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span>Array</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>                                a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">876323262645176354L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Saves the state of this {@code LinkedList} instance to a stream     * (that is, serializes it).     *     * @serialData The size of the list (the number of elements it     *             contains) is emitted (int), followed by all of its     *             elements (each an Object) in the proper order.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectOutputStream</span> s<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span> <span class="token punctuation">{</span>        <span class="token comment">// Write out any hidden serialization magic</span>        s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Write out size</span>        s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Write out all elements in the proper order.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Reconstitutes this {@code LinkedList} instance from a stream     * (that is, deserializes it).     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectInputStream</span> s<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>        <span class="token comment">// Read in any hidden serialization magic</span>        s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Read in size</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Read in all elements in the proper order.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;     * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this     * list.     *     * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED} and     * {@link Spliterator#ORDERED}.  Overriding implementations should document     * the reporting of additional characteristic values.     *     * @implNote     * The {@code Spliterator} additionally reports {@link Spliterator#SUBSIZED}     * and implements {@code trySplit} to permit limited parallelism..     *     * @return a {@code Spliterator} over the elements in this list     * @since 1.8     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LLSpliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/** A customized variant of Spliterators.IteratorSpliterator */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">LLSpliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BATCH_UNIT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// batch array size increment</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_BATCH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">25</span><span class="token punctuation">;</span>  <span class="token comment">// max batch array size;</span>        <span class="token keyword">final</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span> <span class="token comment">// null OK unless traversed</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> current<span class="token punctuation">;</span>      <span class="token comment">// current node; null until initialized</span>        <span class="token keyword">int</span> est<span class="token punctuation">;</span>              <span class="token comment">// size estimate; -1 until first needed</span>        <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span> <span class="token comment">// initialized when est set</span>        <span class="token keyword">int</span> batch<span class="token punctuation">;</span>            <span class="token comment">// batch size for splits</span>        <span class="token class-name">LLSpliterator</span><span class="token punctuation">(</span><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> est<span class="token punctuation">,</span> <span class="token keyword">int</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>est <span class="token operator">=</span> est<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>expectedModCount <span class="token operator">=</span> expectedModCount<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getEst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> s<span class="token punctuation">;</span> <span class="token comment">// force initialization</span>            <span class="token keyword">final</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lst<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> est<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>lst <span class="token operator">=</span> list<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    s <span class="token operator">=</span> est <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    expectedModCount <span class="token operator">=</span> lst<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>                    current <span class="token operator">=</span> lst<span class="token punctuation">.</span>first<span class="token punctuation">;</span>                    s <span class="token operator">=</span> est <span class="token operator">=</span> lst<span class="token punctuation">.</span>size<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">estimateSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">getEst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">trySplit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">getEst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> current<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> n <span class="token operator">=</span> batch <span class="token operator">+</span> BATCH_UNIT<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> s<span class="token punctuation">)</span>                    n <span class="token operator">=</span> s<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> MAX_BATCH<span class="token punctuation">)</span>                    n <span class="token operator">=</span> MAX_BATCH<span class="token punctuation">;</span>                <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                current <span class="token operator">=</span> p<span class="token punctuation">;</span>                batch <span class="token operator">=</span> j<span class="token punctuation">;</span>                est <span class="token operator">=</span> s <span class="token operator">-</span> j<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token class-name">Spliterators</span><span class="token punctuation">.</span><span class="token function">spliterator</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token class-name">Spliterator</span><span class="token punctuation">.</span>ORDERED<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getEst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> current<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                est <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token class-name">E</span> e <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">;</span>                    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAdvance</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getEst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> current<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">--</span>est<span class="token punctuation">;</span>                <span class="token class-name">E</span> e <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">;</span>                current <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">characteristics</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">Spliterator</span><span class="token punctuation">.</span>ORDERED <span class="token operator">|</span> <span class="token class-name">Spliterator</span><span class="token punctuation">.</span>SIZED <span class="token operator">|</span> <span class="token class-name">Spliterator</span><span class="token punctuation">.</span>SUBSIZED<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合ArrayList</title>
      <link href="/2021/05/15/arraylist/"/>
      <url>/2021/05/15/arraylist/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>ArrayList的底层是基于数组实现的，类型为:Object[] elementData</li><li>支持随机访问，意味着查询效率高，增删效率低。</li><li>使用频率很高——正常使用的场景都是用来查询，不涉及频繁的增删。</li><li>线程不安全，与之对应的线程安全集合为vector</li><li>遍历速度也较快，由于内存的连续性，CPU内部缓存结构会缓存连续内存片段，可以大幅降低读取内存的性能开销</li><li>不适合用来做队列的底层数组，因为队列性质：尾部插入，首部删除。这两个操作都需要数组的数据整体搬迁。如果使用定长环型数组可以实现队列。</li><li>可以用来做栈，因为push和pop不涉及多个元素遍历与移动</li><li>将<code>ArrayList</code>作为默认首选,只有因为经常从表中间插入删除而导致性能下降时,才选择<code>LinkedList</code></li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>该类支持快速随机访问。</li><li>数组的默认大小为 10，可扩容</li><li>允许null值</li><li>add()的均摊开销是常数级别，均摊花费为O(1)？</li><li>在分配大量元素前,使用ensureCapacity减少重新分配的次数？</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="List-lt-Element-gt"><a href="#List-lt-Element-gt" class="headerlink" title="List< Element >"></a>List&lt; Element &gt;</h3><ul><li>声明一些数组操作的通用方法。</li></ul><h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>要重写<code>clone()</code>则必须实现<code>Cloneable</code>的接口,否则会报<code>CloneNotSupportedException </code>异常</p><p><code>Cloneable </code>接口为空,只是个合法调用 <code>clone</code>方法的标识</p><h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><ul><li>是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。</li><li>如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</li></ul><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable接口也为空,只是个合法调用方法的标识目的是实现序列化:可以将一个对象的转换成字节流,写成文件,需要的时候可以从流中再次读取(反序列化)。实现序列化之后的对象,可以通过IO操作进行读写</p><h2 id="操作与源码结合分析"><a href="#操作与源码结合分析" class="headerlink" title="操作与源码结合分析"></a>操作与源码结合分析</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>添加元素时使用 <code>ensureCapacityInternal()</code> 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 <code>oldCapacity+oldCapacity/2</code>。其中 <code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（<code>oldCapacity</code> 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 <code>ArrayList</code> 对象时就指定大概的容量大小，减少扩容操作的次数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//数组元素+1</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//底层元素+1位置的索引元素为新元素</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//DEFAULT_CAPACITY就是默认数组大小为10的变量</span><span class="token comment">//数组扩容时，size会+1，作为minCapacity传入下面确认数组容量的函数中</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//得到了数组最小容量之后，调用真正让数组扩容的函数</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//若当前最大容量大于底层数组的长度，调用grow函数</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// overflow-conscious code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 记录原来的数组元素长度</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 新数组长度大概为原元素的1.5倍</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 若当前计算之后的新数组长度比min小，直接将之前计算的minCapacity作为新的数组元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token comment">// MAX_ARRAY_SIZE是规定的最大数组长度 MAX_VALUE = 0x7fffffff - 8</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>    <span class="token comment">// 将原数组复制到新数组中，就是一个复杂度O（n）的操作，开销很大</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//如果超过了Max，则只能给予最大的数组长度</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>        <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>    MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>需要调用 <code>System.arraycopy() </code>将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//被删除数组元素</span>    <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被移动的数组长度</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//让索引处值为空（之后会被垃圾回收）</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><strong>定义</strong></p><p>一般情况下，创建的对象的生命周期在程序终止的时候就终结了。但是，当在程序不运行的情况下需要用到对象信息的时候，就需要用到序列化。序列化是将一个对象转换成为一个字节序列，该字节序列随后可以写入磁盘或者在网络中传输，最后在需要的时候能够将这个字节序列恢复成为原来的对象。</p><p><strong>数组序列化</strong></p><p>数组的序列化就是将数组的数据转化为字符串，以便传递和数据库存储。而对应的反序列化就是将字符串的数据转化成为数组数据了。</p><p>序列化对应的函数为 <code>serialize()</code>, 反序列化对应的函数为：<code>unserialize() </code>。可以将前者序列化之后的数据存到数据库的某个字段中，使用时再通过反序列化处理。</p><p><code>ArrayList </code>基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组 <code>elementData </code>使用 transient 修饰，该关键字声明数组<strong>默认</strong>不会被序列化。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment">// non-private to simplify nested class access</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>ArrayList </code>实现了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制只序列化数组中有元素填充那部分内容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectInputStream</span> s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>    elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token comment">// Read in size, and any hidden stuff</span>    s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Read in capacity</span>    s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ignored</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// be like clone(), allocate array based upon size not capacity</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> elementData<span class="token punctuation">;</span>        <span class="token comment">// Read in all elements in the proper order.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectOutputStream</span> s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token punctuation">{</span>    <span class="token comment">// Write out element count, and any hidden stuff</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Write out size as capacity for behavioural compatibility with clone()</span>    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Write out all elements in the proper order.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化时需要使用 <code>ObjectOutputStream</code> 的 <code>writeObject()</code> 将对象转换为字节流并输出。而 <code>writeObject() </code>方法在传入的对象存在 <code>writeObject()</code> 的时候会去反射调用该对象的 <code>writeObject() </code>来实现序列化。反序列化使用的是 <code>ObjectInputStream</code> 的 <code>readObject()</code> 方法，原理类似。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h3><p>对于错误情况的快速反应</p><p>源码中有不少操作是<code>modCount++</code></p><p><code>modCount</code> 用来记录 <code>ArrayList</code> 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 <code>modCount</code>是否改变，如果改变了需要抛出 <code>ConcurrentModificationException</code>。代码参考上节序列化中的 <code>writeObject()</code> 方法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 51. 数组中的逆序对</title>
      <link href="/2021/05/08/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-dui/"/>
      <url>/2021/05/08/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-dui/</url>
      
        <content type="html"><![CDATA[<p>本题想求一个数组中包含的逆序对个数。</p><p>逆序对的定义为:如果数组中索引靠前的元素大于索引靠后的元素，那么它们构成一个逆序对。</p><p>暴力解法很好想，每一个数都查询后面的数是否小于它即可，这样的复杂度为O(n^2)，本题数组长度最大可能有50000，说明这样的复杂度不能被接收，考虑如何优化。这里的方式非常巧妙，利用了分治的思想。</p><p>以<strong>归并排序</strong>为主要解题方式。</p><h2 id="归并排序思路"><a href="#归并排序思路" class="headerlink" title="归并排序思路"></a>归并排序思路</h2><p>归并排序的核心效果是，归并之前的子数组都分别有序。算法的思路为，在正常归并排序的过程中，归并时顺带统计逆序对的个数。</p><p>首先需要理解原理，为什么可以在归并时统计逆序对的个数？假设现在有两个大小为4的数组，它们要合并为大小为8的。</p><p>【1 4 7 8】 【2 3 5 6】</p><p>   我们知道，在归并排序过程中，最开始，会有两个指针（假设为i , j)分别指向这两个子数组的首部，即指向1，2 .,并且创建一个等大空间用来存储它们俩的归并结果。</p><p>如果a[i] &lt; b[j] （此时：1，2）。我们知道，b[j]是右边数组最小的元素，所以a[i]永远不会构成逆序对。则向归并数组中加入a[i]，并让i++.</p><p>若a[i] &gt; b[j] （此时：4，2）。我们知道，<strong>a[i] 是左边数组最小的元素，所以a[i] 及a[i]之后的所有元素都与b[j] 构成逆序对</strong>，这时，我们统计逆序对个数，然后照常让b[j] 加入归并数组，再让j++。其实，这时的逆序对个数即为i到数组a末尾元素的个数。</p><p>当然，如果i 和 j其中有一个先到达了终点，之后的归并便不用比较。这两个判断可以在所有判断语句之前。</p><h2 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h2><p>在j被归并到数组时，计算i到子数组末尾的元素个数，作为逆序对个数即可。</p><p><strong>分</strong>：从数组N不断递归二分数组，直到分到每个数组大小为1时停止。mergeSort函数的参数为数组头指针和数组尾指针。初始的调用语句为：</p><pre class="line-numbers language-none"><code class="language-none">mergeSort(0,nums.length - 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在递归函数中，第一句代码永远是判断终止条件，这里的条件是当左指针&gt;=右指针。因为每次递归的参数改变为(l + r) / 2;所以当r = l + 1时,参数值为1 + 0 = 1 = r。则表示递归终止。</p><p>之后紧接着的代码为递归的划分，然后递归的调用函数本身。</p><p>再接的代码才是递归函数的处理，也就是合并部分：</p><p><strong>合</strong>：合并阶段，首先复制需要合并的数组内容，作为辅助数组的值。这个思路是以原来的输入数组作为最终归并结果，辅助数组作为值判断依据。</p><p>为了代码美观，不统计逆序对的判断单列出来，统计的放在else语句中。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O（NlogN)。因为第一次划分需要logN的时间，之后归并需要分别扫描所有的元素，需要N的时间。</p><p>空间复杂度：O（N）。一个辅助数组来存储归并结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">class Solution {    int[] nums, tmp;    public int reversePairs(int[] nums) {        this.nums = nums;        tmp = new int[nums.length];        return mergeSort(0, nums.length - 1);            }        private int mergeSort(int m, int n) {        //终止条件        if(m &gt;= n) return 0;        //递归划分        int mid = (m + n)/2;        int res = mergeSort(m, mid) + mergeSort(mid + 1, n);        //合并处理        int i = m, j = mid + 1;        //初始化tmp        for(int k = m; k &lt;= n; k++) {            tmp[k] = nums[k];        }        for(int k = m; k &lt;= n; k++) {            if(i == mid + 1) {               nums[k] = tmp[j++];            }            else if(j == n + 1 || tmp[i] &lt;= tmp[j]) {               nums[k] = tmp[i++];            }            else{                nums[k] = tmp[j++];                res += mid - i + 1; //统计逆序对            }        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer49</title>
      <link href="/2021/05/06/jian-zhi-offer49/"/>
      <url>/2021/05/06/jian-zhi-offer49/</url>
      
        <content type="html"><![CDATA[<p>本题要找对应序号的丑数。</p><p>因为丑数的性质为<strong>只</strong>包含质因子为2或3或5的数。</p><p>可以显然得出，”丑数 = 某较小丑数 * 某因子“</p><p>则可以使用动态规划来完成递推。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>若有已知长度为n的丑数序列x1~xn，求第n+1个丑数，那么这个丑数必须得刚刚好比xn大，这意味着他需要在被生成之前与周围可能争夺这个丑数位置的值进行比较。当然，首先他一定是这么生成的：</p><ul><li>xn+1 = xa x 2</li><li>xn+1 = xb x 3</li><li>xn+1 = xc x 5 </li></ul><p>首先根据上面的逻辑，他应该是这三个值中最小的一个，则xN+1 = </p><p>min(xa, xb, xc)。</p><p>那么，如何确保之后的值在x2,x3,x5之后，一定比xn+1大呢，万一出现了xn+1生成之后，xa x 2的丑数值钻进了xn 和 xn+1之间，就会得到错误的结果，所以还需要顺带判断一下。</p><p>我们可以将这个判断卡在xa , xb, xc本身上，具体如下：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210506184523194.png" alt="image-20210506184523194"></p><h2 id="动态规划解析"><a href="#动态规划解析" class="headerlink" title="动态规划解析"></a>动态规划解析</h2><ul><li>状态定义：规定动态规划列表dp，dp[i] 代表 i + 1个丑数</li><li>转移方程： <ol><li>索引a, b, c 位置正确时，取上述最小值</li><li>每次计算完成后，都需要更新索引位置，独立判断dp[i] 和 dp[a] x 2，dp[b] x 3, dp[c] x 5的大小关系，若相等则将对应索引a,b,c+1。这里相等才+1的原因是，首先dp[i] 一定是最小的一个，并且它由之前的这三个值中的某一个生成，他一定会与其中一个相等，而这个索引必须前移不然没有可能再通过x2/x3/x5 来完成新的丑数生成。</li><li>递推的时候，已经保证了xn + 1是最接近xn的，只需要更新索引来完成递推必要条件</li></ol></li><li> 初始状态：dp[0] = 1,第一个丑数为1</li><li>返回值：dp[n - 1] 即返回第 n 个丑数</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度O(N) ，其中N = n,因为遍历次数与n相同</li><li>空间复杂度O(N) ,dp数组的额外空间</li></ul><p><strong>代码</strong></p><pre class="line-numbers language-none"><code class="language-none">class Solution {    public int nthUglyNumber(int n) {        int a = 0, b = 0, c = 0;        int[] dp = new int[n];        dp[0] = 1;        for(int i = 1; i &lt; n; i++) {            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;            dp[i] = Math.min(Math.min(n2, n3), n5);            if(dp[i] == n2) a++;            if(dp[i] == n3) b++;            if(dp[i] == n5) c++;        }        return dp[n - 1];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer48</title>
      <link href="/2021/04/28/jian-zhi-offer48/"/>
      <url>/2021/04/28/jian-zhi-offer48/</url>
      
        <content type="html"><![CDATA[<p>本题求“最长”，且最长与次长之间具有充要关系，考虑用动态规划解题。</p><h2 id="动态规划解析："><a href="#动态规划解析：" class="headerlink" title="动态规划解析："></a>动态规划解析：</h2><h3 id="状态定义："><a href="#状态定义：" class="headerlink" title="状态定义："></a>状态定义：</h3><p> 设动态规划列表 dp ，dp[j] 代表以字符 s[j]s[j] 为结尾的 “最长不重复子字符串” 的长度。</p><h3 id="转移方程："><a href="#转移方程：" class="headerlink" title="转移方程："></a>转移方程：</h3><p>固定右边界j,设字符s[j]左边距离最近的相同字符为s[i], 即s[i] =  s[j]。</p><ol><li>i &lt; 0,s[j]左边没字符，dp[j] = dp[j - 1] + 1(初始情况)</li><li>dp[j - 1] &lt; j - i,说明s[i] 在字符串dp[j - 1] 区间之外，则dp[j] = dp[j - 1] +1。这里需要细致讲解一下，其实影响当前字符加入进来的时候是不是最长字符，就看这个新进来的字符到底有没有在已知最长字符串中任何一个重合，那么每次都一个一个遍历肯定很麻烦，所以靠记录的方式看第一次和他相同的字符出现的索引，那么这个索引怎么用呢？靠j - i来判断，我们假设当前最长字符串大小为3，即dp[j - 1] = 3，如果新进来的这个字符(j 索引对应的字符) 正好和当前字符串最前面的一个字符相同，那就出现了重复了，就不能再无脑让长度+1了，这个相同的情况用数学表达式来说就是 j - i = dp[j - 1]。现在能明白为什么j - i &gt; dp[j - 1] 时，可以让最长长度接着+1了吧。</li><li>dp[j - 1] &gt;= j - i。那dp[j] 的左边界由s[i] 决定，即dp[j] = j - i。取j - i 则默认当前值的最大字串要包含j索引的字符，向前取到i索引的字符的后面一个，得到dp[j]。</li><li>但我们要取最大的，所以要比较dp[j - 1]和dp[j]谁更大，把大的作为dp[j]</li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>可以用哈希表来统计各字符最后一次出现的索引位置，这样在遇到新字符的时候直接查表，复杂度很小的同时，还可以更新表和把索引值用来判断，逻辑清晰。</p><pre class="line-numbers language-none"><code class="language-none">class Solution {    public int lengthOfLongestSubstring(String s) {        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();        int res = 0, tmp = 0;        for(int j = 0; j &lt; s.length(); j++) {            int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i            dic.put(s.charAt(j), j); // 更新哈希表            tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些基础概念总结</title>
      <link href="/2021/04/21/yi-xie-ji-chu-gai-nian-zong-jie/"/>
      <url>/2021/04/21/yi-xie-ji-chu-gai-nian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h4><ul><li>private</li><li>protected</li><li>public</li></ul><p>这三个修饰符可以修饰变量，方法，类，接口等。表示程序级别之间的访问权限，如果不加则表示包级之间可以随意访问。</p><ul><li>类可见表示其他类可以用这个类创建实例对象</li><li>成员可见表示其他类可以用这个类的实例对象访问这个成员</li></ul><p>protected用于修饰成员，这个修饰的效果是对于继承它的子类，这些成员可见，而这个修饰符对于修饰类没有效果。</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>接口本来是抽象类的延伸，但再JDK 8之前两个概念完全重合，既接口中不能有任何方法的实现。</p><p>然而因为不允许任何方法实现的接口维护成本太高（其实就是如果想要修改一个业务，还得根据接口找到实现类里面去更改）。所以JDK 8之后接口就允许方法实现了。</p><ul><li>JDK 8 接口的成员默认且只能是public</li><li>接口字段默认final或static</li></ul><p><strong>什么时候适合使用接口？</strong></p><ol><li>需要让许多不相关的类实现同样名字的方法</li><li>需要使用多重继承</li></ol><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h4><p>在继承体系中，当子类实现一个和父类名字一样的成员方法时，叫做重写。</p><p>重写需要满足以下规则</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用@Override注解，可以让<strong>编译器检查</strong>是否满足上面的规则</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>想要理解反射概念，需要先知道：</p><ul><li>Java中，每个类都有一个class对象，包含与类相关的信息。</li><li>编译时，根据编译的类，产生一个.class文件，文件中就是类包含的对象</li><li>类加载相当于class对象的加载，在第一次使用类时（初始化一个实例），这个类（class）才会动态加载到JVM中。</li></ul><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可扩展性：应用程序可以创建一个可扩展对象的实例，这个创建方法是利用全限定名，创建这个可扩展对象实例的作用是使用来自外部的用户自定义类</li><li>类浏览器：一个类的浏览器需要可以看到所有类的成员，比如IDE在程序员编写代码时就可以根据反射得到的类信息，编写正确的代码</li><li>调试器：调试器需要检查类私有成员。</li><li>测试工具：测试工具利用反射，自动调用类里定义的可被发现（打开IDE的类能看见的第一层的）API，确保一组测试中有较高的代码覆盖率。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>性能开销：反射设及动态类型解析，JVM无法对这些代码进行优化。反射操作的效率比那些非反射操作低得多</li><li>安全限制：使用反射技术要求程序运行环境安全。</li><li>内部暴露：反射允许代码执行一些不被允许的操作（比如访问私有属性和方法）。</li></ul><p>上面的这些优缺点由于没有实例会非常难理解，可能以后遇到了真正使用反射的时候才能理解这些。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Java中定义基类Throwable来表示处理异常抛出情况。分为Error和Exception两种。Error表示JVM无法处理的错误，Exception分两种</p><ul><li>受检：顾名思义，可以被检查到并且修正的异常：常用的try…catch语句的使用。</li><li>非受检：数组越界，除0等可以被识别但是不能被修复的操作，程序直接崩溃，返回的异常。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>集合类的数据类型一个关键特性，我们可以用它们存储任意类型的数据，它被称为泛型。泛型其实很好理解，就是我们的抽象数据类型可以用它们存储任意类型的数据。</p>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaBasic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关键字final&amp;static</title>
      <link href="/2021/04/20/guan-jian-zi-final-static/"/>
      <url>/2021/04/20/guan-jian-zi-final-static/</url>
      
        <content type="html"><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>若作用于基本数据类型，数据在创建后不可修改</li><li>若作用于引用数据类型，引用本身不能被修改，但其引用的对象本身可以修改</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>private关键字被隐式指定为final</li><li>如果一个private方法声明后，在另一个对象重新创建同样名字的方法，那么这个方法不是对原private方法的重写，而是新建了一个方法。</li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li>final声明的类不允许被继承，但可以继承别的类</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><ul><li>静态变量又称类变量，如果在类中定义了静态变量，它会独立的存在一块内存中。所有的该类其他实例都可以通过变量名的方式直接访问它，且访问的都是同一个变量（同一份地址）</li><li>实例变量就是不加static修饰的类中变量，与上面的区别是，每一次创建一个类实例就会创建一个新的实例变量。</li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li>静态方法在类加载时存在，其必须在定义时实现，也就是他不能是一个抽象方法。</li><li>在实现的时候，只能访问该对象中的静态方法和静态变量</li></ul><h4 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h4><ul><li>在类初始化时，该语句块会运行一次</li></ul><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul><li>非静态内部类的初始化依赖于外部类，想要创建它必须先实例化外部类，然后再用它初始化内部类</li><li>静态内部类可以按名直接创建实例</li></ul><h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><ul><li>静态变量和静态方法会在类被初始化的时候优先被初始化</li><li>它们之间的初始化顺序取决于代码语句顺序</li><li>如果有继承情况<ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaBasic </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaString</title>
      <link href="/2021/04/17/javastring/"/>
      <url>/2021/04/17/javastring/</url>
      
        <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Java中的String比较特殊，与它密切相关的还有StringBuilder和StringBuffer两种类。</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String类被声明为final，因此它不可被继承。而Integer等包装类也不能被继承，他们之间有共同的设计思路。</p><ul><li>在Java 8 中，String包装了一个声明final的char型数组，来存储字符数据</li><li>在Java 9 中，String类的实现改用声明为final的byte数组存储，并规定编码规则</li></ul><p>其实这两个数组被声明为final就意味着，如果对象被创建，则内部数组值固定不能再引用其他数组，同时String类内部也没有提供改变数组的方法，这样保证了String<strong>不可变</strong>。</p><h3 id="String，StringBuffer和StringBuilder"><a href="#String，StringBuffer和StringBuilder" class="headerlink" title="String，StringBuffer和StringBuilder"></a>String，StringBuffer和StringBuilder</h3><ol><li>可变性<ul><li>String不可变</li><li>StringBuffer和StringBuilder可变（所以一般想要修改一个字符串的值，先将他转化为同值的StringBuffer或StringBuilder，更改值之后再转回来）。</li></ul></li><li>线程安全<ul><li>String不可变，因此线程安全</li><li>StringBuilder不安全（可变但没有加锁）</li><li>StringBuffer线程安全，内部使用synchronized进行同步</li></ul></li></ol><p>除了线程安全之外，String的不可变还有哪些好处？</p><ol><li>可以缓存hash值<ul><li>因为String 的hash值经常被使用，比如HashMap中的String可以被作为key，不可变的特性使hash值也不可变，因此只需要一次计算</li></ul></li><li>StringPool使用条件<ul><li>StringPool可以对那些已经被创建过的String对象创建引用，如果String变了，引用将失效。</li></ul></li><li>安全性<ul><li>String经常作为参数。比如网络链接参数，如果String可变，那么在链接过程中String改变，改变String 的一方会认为连接了其他主机。</li></ul></li><li>线程安全<ul><li>多个线程同时访问不会出现脏写脏读等并发问题</li></ul></li></ol><h3 id="何为StringPool？为什么要创建它？"><a href="#何为StringPool？为什么要创建它？" class="headerlink" title="何为StringPool？为什么要创建它？"></a>何为StringPool？为什么要创建它？</h3><p>StringPool是字符串常量池，保存着所有<strong>字符串字面量</strong>（literal strings）,这些字面量在编译时就确定了，我们可以通过intern()方法，将自己创建的字符串添加到String Pool中。</p><p>intern()方法的执行逻辑是，执行时，查询已有StringPool中是否有等值存储，命中则返回其引用。若不命中则将本字符串加入其中，并返回这个新引用。</p><p>StringPool存在原因：</p><ol><li>String对象的不变性，当程序运行过程用到多个相同值的String对象，就不需要新建那么多个同样值的对象，而是传一个值的引用。</li><li>为了节省空间，增加访问速度（如String这样的对象数据类型，其实==比较的是内存地址的值是否相同，比equals()比较字符串值是否相同快（String重写了equal()方法，比较两个字符串对象的值是否相同））。反正String值不可变，比较引用当然比比较值要快的多。</li><li>所有字符串常量都被合并，只占用一个空间</li></ol><h3 id="创建一个字符串对象实例"><a href="#创建一个字符串对象实例" class="headerlink" title="创建一个字符串对象实例"></a>创建一个字符串对象实例</h3><p>如果执行String s = new String(“abc”);这种方式一共会创建两个字符串对象，前提是String Pool中还没有”abc“字符串对象。</p><ol><li>”abc“属于字符串字面量，编译时会在StringPool创建一个字符串对象，指向这个”abc“字符串字面量，</li><li>而使用new会在堆中创建一个字符串对象（String类实例）</li></ol><p>String构造函数的源码，可以看到将一个字符串对象作为另一个字符串对象构造函数参数时，不会将其字符串的字面量数组复制并传给新的，而是让这两个对象指向同一个数组。</p>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
          <category> Java数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Java数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC</title>
      <link href="/2021/04/16/springioc/"/>
      <url>/2021/04/16/springioc/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h1><h2 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h2><p>IOC（Inversion of Control)是一种编程思想，如果一旦用户需求改变，程序杨就需要去代码底层大量的更改的话，代码不够具有持久性。为了让两者能够平衡的互相运行，基于代理模式这个设计模式思想，提出了控制反转(IOC) 的编程思想。</p><ul><li>使用控制反转（IOC)，程序由主动创建对象（控制权在程序员手上），变成了被动的接收者（控制权在用户手上）。</li><li>这种思想本质解决了上面问题，让程序员不需要关注管理对象的创建，让系统与用户需求解耦，更加专注在业务实现上。</li></ul><p>而DI(Dependency Injection) (依赖注入)是实现IOC的一种方法，</p><ul><li>在没有IOC的程序中，我们使用面向对象编程的思想。</li><li>对象的创建和对象的依赖完全硬编码在程序中，对象创建由程序自己控制。</li><li>而控制反转后将对象的创建转移给了第三方，其实所谓控制反转就是获得依赖对象的方式反转。</li></ul><p>在Spring中，控制反转的实现是一种通过描述（XML或注解）并通过第三方去<strong>生产或获取</strong>特定对象的方式，在Spring中实现控制反转的是IOC容器，实现方法是依赖注入。</p><h2 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h2>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringIOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包队列栈算法4阅读笔记</title>
      <link href="/2021/04/16/bei-bao-dui-lie-zhan-suan-fa-4-yue-du-bi-ji/"/>
      <url>/2021/04/16/bei-bao-dui-lie-zhan-suan-fa-4-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>背包，队列和栈都是一种抽象数据类型，数据类型的值是一组对象的集合(这句话的意思是，一个抽象类中的成员变量，其实就是一些数据类型，而这些成员变量便是这个对象的数据类型，即一组对象的集合），所有操作都是关于添加、删除或是访问集合中的对象。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>集合类的数据类型一个关键特性，我们可以用它们存储任意类型的数据，它被称为泛型。泛型其实很好理解，就是我们的抽象数据类型可以用它们存储任意类型的数据。</p><h2 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h2><p>类型参数必须被实例化为引用类型，Java有一种特殊机制，可以让泛型代码能够处理原始数据类型。</p><p>Java的封装类型都是<strong>原始数据类型所对应的引用数据类型</strong>，比如Integer——int。一般在数组初始化定义类型，使用Integer而不是用int。</p><p>在处理赋值语句、方法和参数和算术逻辑表达式时，Java会自动在引用类型和对应原始数据类型之间进行切换。</p><p>自动将一个原始数据类型转换为一个封装类型的操作被称为自动装箱（int -&gt; Integer) , 反过来叫自动拆箱。</p><h2 id="可迭代的集合类型"><a href="#可迭代的集合类型" class="headerlink" title="可迭代的集合类型"></a>可迭代的集合类型</h2><p>用户一般都有逐个访问集合中每一个元素的需求，这是一种模式。在java中这是一种特性，具体的实现叫做for each语句。</p><p>也就是说，这些数据类型可迭代的优势就是可以用简洁的代码遍历它们，比如for（Transaction t : collection）.</p><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>背包特点：</p><ul><li>不支持删除元素</li><li>迭代顺序不确定，和用例无关</li><li>元素处理顺序不重要，可以简单处理收集和迭代需求。</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre class="line-numbers language-none"><code class="language-none">Bag();//创建一个背包void add(Item item); //添加一个元素boolean isEmpty(); //背包是否为空int size(); //背包中的元素数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="先进先出队列"><a href="#先进先出队列" class="headerlink" title="先进先出队列"></a>先进先出队列</h2><ul><li>先进先出策略，先加入队列的元素会被先操作到</li><li>元素处理顺序就是它们被添加到队列的顺序</li><li>有这么一个实例，想要得到最开始不知道有多少个整数的整数有多少个，这就可以使用队列来实现，先放入队列，再得到队列大小，最后按顺序放入数组。</li></ul><h2 id="下压栈"><a href="#下压栈" class="headerlink" title="下压栈"></a>下压栈</h2><ul><li>和队列一起理解，只不过放入元素的顺序和体感取到的元素顺序正好相反。</li><li>可以用栈解决经典的算术表达式求值问题，达到先算括号内。<ol><li>操作数压入操作数栈</li><li>运算符压入运算符栈</li><li>忽略左括号</li><li>遇到右括号时，弹出一个运算符，弹出此运算符需要的操作数个数，将结果重新压入操作数栈</li></ol></li></ul><h3 id="定容栈"><a href="#定容栈" class="headerlink" title="定容栈"></a>定容栈</h3><p>看一个容量固定的字符串类型栈的实现，之后拓展到完整的实现。</p><p>假设这个定容栈底层用一个String数组来实现。</p><p>实例变量为一个用于保存栈中的元素数组a[]，和一个用于保存栈中元素数量的N。</p><ul><li>若删除一个元素，返回a[–N],</li><li>若添加一个元素，a[N++] = newitem</li></ul><p>这里为什么先 N -1再返回，因为N代表栈的元素数量，它永远比数组索引大1，所以我们可以理解为，栈的顶部位于a[N - 1]。</p><p>数组中的元素顺序和它们被插入的顺序相同（只不过返回的是数组尾部）。</p><pre class="line-numbers language-none"><code class="language-none">public class FixedCapacityStackOfStrings {    private String[] a; //存储数据实例    private int N;//大小    public FixedCapacityStackOfStrings(int cap) {        a = new String[cap];    }    public boolean isEmpty() {        return N == 0;    }    public int size() {        return N;    }    public void push(String item) {        a[N++] = item;//这里不安全，如果N++大于原本数组长度，就会溢出    }    public Strings pop() {        return a[--N];//同理，会越界    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了让我们的栈能够支持更多数据类型，让它支持泛型，需要在这个抽象数据类型上进行一些更改。</p><p>假设我们的下压栈可以处理任意类型的数据，我们把这个类型预定义为：Item，在创建下压栈的时候，语句为：</p><pre class="line-numbers language-none"><code class="language-none">public FixedCapacityStackOfStrings(Item item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>想要实现在代码底层不知道类型，但是在用户创建实例的时候指定类型，就可以操作这个类型的需求，我们（包含java）需要做到：</p><ol><li><p>实际的类型必须是引用类型：用例可以通过自动装箱机制来完成</p></li><li><p>Java内部需要判断当前Item类型的值被赋予的是不是Item类型，尽管在底层它并不知道Item的具体类型</p></li><li><p>Java中不允许创建泛型数组，但是给出了一种替代方式：</p><pre class="line-numbers language-none"><code class="language-none">a = (Item[]) new Object[cap];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>可以发现，其实我们的泛型代码和之前的类实现差不多（把基础类型String缓存Item）就好了，其实是因为核心的功能还是Java底层实现了。</p><h3 id="调整数组的大小"><a href="#调整数组的大小" class="headerlink" title="调整数组的大小"></a>调整数组的大小</h3><p>在实现时选择使用数组，是因为数组的大小一旦创建变不可更改。</p><p>栈使用的空间仅仅是这个最大空间的一部分。上面的类实现代码可以直接++N也是因为默认当前数组大小永远&gt;=N，当然为了更加严谨，需要在原来的类中加入isFull()方法来判断N是否越界。</p><p>数组固定大小造成的一系列问题，在这里就不多说了。为了保证我们的底层数组既能存下所有元素，又不浪费太多空间，采用动态调整数组大小的方式：</p><ol><li><p>首先实现一个，将大小为N&lt;=max的栈元素全部移动到max大小的数组中的方法。</p><pre class="line-numbers language-none"><code class="language-none">private void resize(int max) {   //temp是新数组，a是原本的数组   Item[] temp = (Item[]) new Object[max];   for(int i = 0; i &lt; N; i++) {      temp[i] = a[i];   }   a = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在push（）中，检查数组是否太小。具体方法：检查栈大小N和数组大小a.length是否相等来检查数组是否能够容纳新元素，如果没有多余空间，就将数组长度加倍。</p><pre class="line-numbers language-none"><code class="language-none">public void push(Item item) {   if(N == a.length) {      resize(2*a.length);//这一步用到了上面的函数，这就是为什么要实现上面的函数，否则数组的长度不可操作   }   a[N++] = item;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在pop（）方法中,首先删除栈顶元素，检查数组是否过大。如果数组太大，就让数组长度减半。显然，数组太大的数学表达式是：a.length &gt; N/4（因为上面的pop需要当前栈大小的两倍）</p><pre class="line-numbers language-none"><code class="language-none">public Item pop() {   Item item = a[--N];   a[N] = null;//避免对象游离   if(a.length &gt; N/4) {     resize(a.length / 2);   }   return item;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="对象游离"><a href="#对象游离" class="headerlink" title="对象游离"></a>对象游离</h3><p>在pop（）方法中，单纯的–N返回值得到了正确的结果，但是a[N]这个数组中的值仅仅是索引被断开，被分配的内存依然没有回收，知识访问它的索引断了。这种情况需要利用Java的垃圾回收机制来完成，这里浅显的理解就是，将它值设置为null。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>集合数据类型必须支持迭代访问元素，实现一个iterator()方法，返回Iterator对象。</p><p>Iterator类包含两个方法：hasNext()和next()</p><p>由于迭代中的所有必须实现的方法固定，我们可以把这些方法封装成一个接口，在Java中已经定义了迭代的接口。如果想让我们的类可迭代，在他的声明中加入implements Iterable<item>  ,这个被implements的接口实现如下</item></p><pre class="line-numbers language-none"><code class="language-none">public interface Iterable&lt;Item&gt; {   Iterator&lt;Item&gt; iterator();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>继承这个接口后，我们在类中复写iterator这个方法，返回一个迭代器</p><pre class="line-numbers language-none"><code class="language-none">public Iterator&lt;Item&gt; iterator() {    return new ReverseArrayIterator();//这是一个逆序访问的迭代器}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那这个ReverseArrayIterator 的类在哪里呢？</p><p>这个类其实就是一个迭代器，我们需要让这个迭代器实现上面的hasNext（）和next（）方法，这两个方法被封装在了接口Iterator<item>中，我们可以自己实现这个类，类的方法需要复写上面的方法，实现如下：</item></p><pre class="line-numbers language-none"><code class="language-none">private class ReverseArrayIterator implements Iterator&lt;Item&gt; {   private int i = N;   public boolean hasNext() {      return i &gt; 0;   }   public Item next() {      return a[--i];   }   public void remove() {      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>remove方法这里不定义，是因为避免迭代的时候穿插修改数据的情况。</p><p>这样我们就完成了一个几乎非常完善的下压栈，但是它依然存在下面的问题：</p><ul><li>在pop()方法和push()方法中，需要改变数组的大小，这个操作开销基于数组长度</li></ul><p>于是为了让这一步也变得没有开销，能够动态的处理数据，尝试使用链表来完成下压栈实现。</p><h2 id="下压栈（链表）"><a href="#下压栈（链表）" class="headerlink" title="下压栈（链表）"></a>下压栈（链表）</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种递归的数据结构，或者为空，或者指向下一个结点的引用，每个结点有一个泛型元素（值），和下一个结点的引用（值)。</p><p>实现栈的API：将栈保存为一条链表，栈的顶部就是表头，实例变量first指向栈顶。push的时候，将新元素添加在表头，pop将表头删除，size方法用一个int N保存，push+1，pop -1。isEmpty 判断first是否为null，同时链表本身只要支持泛型，那我们的栈也可以支持，这样我们的栈达到了最终要求的目标：</p><ul><li>可以处理任意类型的数据</li><li>所需空间总是和集合大小成正比</li><li>操作所需时间和集合大小无关</li></ul><pre class="line-numbers language-none"><code class="language-none">public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; {    private Node first; //最近添加的结点    private int N;  //链表长度，栈的大小，定义可以让size（）函数时间复杂度o（1）        private class Node {       Item item;       Node next;    }        public int size() {       return N;    }    public boolean isEmpty() {       return first == null;    }    public void push(Item item) {       Node oldfirst = first;       first = new Node();       first.item = item;       first.next = oldfirst;       N++;    }    public Item pop() {       Item item = first.item;       first = first.next;       N--;       return item;    }    //迭代功能    public Iterator&lt;Item&gt; iterator() {      return new ListIterator();    }    private class ListIterator implements Iterator&lt;Item&gt; {      private Node current = first;      public boolean hasNext() {         return current.next != null;      }      public Item next() {         Item item = current.item;         current = current.next;         return item;      }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面就是完整的下压栈链表实现了，其实基本的框架与用数组实现完全一致，只是因为链表的特性，复写了一些方法的实现。同理，队列和背包其实可以用同样的思路创建出来，这里就不多说了。</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求响应</title>
      <link href="/2021/04/16/http-qing-qiu-xiang-ying/"/>
      <url>/2021/04/16/http-qing-qiu-xiang-ying/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求—相应报文"><a href="#HTTP请求—相应报文" class="headerlink" title="HTTP请求—相应报文"></a>HTTP请求—相应报文</h1><p>网页请求中，客户端发送HTTP请求报文，服务器解析报文，响应相应的返回值和数据组成的报文。</p><h2 id="请求报文的结构"><a href="#请求报文的结构" class="headerlink" title="请求报文的结构"></a>请求报文的结构</h2><ol><li>请求方法，URL，协议版本</li><li>接下来的多行都是请求首部Header：包含首部名称和对应值</li><li>一个空行分开Header和Body</li><li>请求内容主体</li></ol><h2 id="相应报文的结构"><a href="#相应报文的结构" class="headerlink" title="相应报文的结构"></a>相应报文的结构</h2><ol><li><p>协议版本，状态码，描述（描述状态码代表的信息）</p></li><li><p>接下来多行是首部内容（首部名称——对应值）</p></li><li><p>空行</p></li><li><p>相应内容主体</p></li></ol><ul><li>这两种报文的首部Header是由多行（首部名称：值）排列而成的，每一行都是一个独立的首部，对应独立的值。</li><li>请求报文第一行包含的URL，协议版本，请求方法是重点需要关注的内容。</li><li>相应报文的协议版本和状态码</li></ul><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL全称：Uniform Resource Locator，又名统一资源定位符。与他关系密切的名词URI（Uniform Resource Identifier) 统一资源标识符。URI包含URL，URL在URI的基础上增加了定位能力（找到资源具体位置）。URI还包含URN（Uniform Resource Name）统一资源名称，顾名思义它只是个名字。</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210416082336813.png" alt="image-20210416082336813"></p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>HEAD</td><td>和GET方法类似，但不返回内容主体部分</td></tr><tr><td>POST</td><td>传输实体主体（主要用来传输资源，GET是获取）</td></tr><tr><td>PUT</td><td>上传文件，没有权限限制，存在安全性问题，一般不用</td></tr><tr><td>PATCH</td><td>修改资源，但只能部分修改，会将原始资源完全被请求包含的修改资源替代</td></tr><tr><td>DELETE</td><td>和PUT相反，删除文件，同样没有权限机制</td></tr><tr><td>OPTIONS</td><td>查询指定URL支持的方法</td></tr><tr><td>CONNECT</td><td>建立链接隧道，使用SSL和TLS协议把通信内容加密</td></tr><tr><td>TRACE</td><td>追踪路径，服务器会将通信路径返回</td></tr></tbody></table><p>GET和POST的区别</p><ul><li>GET一般是向服务器请求资源，POST把数据发送到后台使用</li><li>GET和POST都能使用额外参数，GET放在URL中，POST放在内容主体中。URL仅仅支持ASCII码，所以如果GET请求参数有中文，需要先编码，空格也是一样</li><li>GET安全POST不安全，GET安全因为它不会改变服务器的状态，但POST会改变，每一次POST请求会在服务器放上一条记录。</li><li>GET方法本身可以缓存，POST不能缓存</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以直到服务器端是正常处理了请求，还是出现了错误。</p><ul><li>1XX （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。</li><li>2XX    Success（成功状态码）    请求正常处理完毕<ul><li>200 OK：请求已正常处理</li><li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul></li><li>3XX    Redirection（重定向状态码）    需要进行附加操作以完成请求</li><li>4XX    Client Error（客户端错误状态码）    服务器无法处理请求<ul><li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li><li>404 Not Found：服务器上没有请求的资源。路径错误等。没有发现文件、查询或URl</li></ul></li><li>5XX    Server Error（服务器错误状态码）    服务器处理请求出错<ul><li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li>501是服务器不支持的请求，无法完成请求</li><li>503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。 通常，这只是暂时状态。</li><li>505时服务器不支持请求的HTTP协议版本，无法完成处理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型</title>
      <link href="/2021/04/15/java-shu-ju-lei-xing/"/>
      <url>/2021/04/15/java-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><p>数据类型是指一组值和一组对这些值操作的<strong>集合</strong>。在Java中分为原始数据类型，和引用数据类型。</p><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>比如说：int（32位），float（单精度32位），double（双精度64位），boolean（表示一位 ，只有两个值0，char（16位Unicode字符），byte（8位），short（16位），long(64位)。</p><p>java编程中，主要使用class构造引用类型，这种风格也叫面向对象编程，对象——保存了某个数据类型的的值的实体。通过此 ，你还可以自己定义自己的数据类型来抽象任意对象。</p><p>抽象数据类型ADT是一种能够对使用者隐藏数据表示的数据类型。（就是自己写类，定义自己的成员数据和对应API，这种类对使用者透明，只需要提供API即可）。</p><h3 id="包装数据类型"><a href="#包装数据类型" class="headerlink" title="包装数据类型"></a>包装数据类型</h3><p>Java的自动装箱和自动拆箱机制：</p><p>类型参数必须被实例化为引用类型，Java有一种特殊机制，可以让泛型代码能够处理原始数据类型。</p><p>Java的封装类型都是<strong>原始数据类型所对应的引用数据类型</strong>，比如Integer——int。一般在数组初始化定义类型，使用Integer而不是用int。</p><p>在处理赋值语句、方法和参数和算术逻辑表达式时，Java会自动在引用类型和对应原始数据类型之间进行切换。</p><p>自动将一个原始数据类型转换为一个封装类型的操作被称为自动装箱（int -&gt; Integer) , 反过来叫自动拆箱。</p><p><strong>Java的每个基本数据类型都对应一个包装类型</strong></p><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 和 Integer.valueOf(123)的区别</p><ul><li>new每次都新建一个对象，这个新建意味着为这个对象分配了独立的内存空间</li><li>而Integer.valueOf(123) ，这个对象使用缓存池（一个已经存储了123这个基础数据类型的对象），对象映射在这个已经创建的对象上，多次调用会一直使用这个对象的引用。</li></ul><p><strong>编译器会在自动装箱过程中调用valueOf()方法</strong></p><p>因此多个值相同且值在缓存池范围内的Integer实例，如果这个Integer对象实例使用的是自动装箱来创建，那么他会使用缓存池内的对象。</p>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring初见</title>
      <link href="/2021/04/13/spring-chu-jian/"/>
      <url>/2021/04/13/spring-chu-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h1><ul><li>spring是为了解决企业开发的复杂性，任何java应用都可以使用。</li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413164120146.png" alt="image-20210413164120146"></p><p>七大模块</p><ul><li>spring-core：支持所有的基础</li><li>spring-aop：</li><li>spring-orm：对象关系映射，比如mybatis</li><li>spring-dao:dao层的支持</li><li>spring-web：webapplicationcontext</li><li>spring-webMVC： JSP等支持</li><li>spring-Context：UI界面支持</li></ul><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>spring官网介绍：现代化的java开发——基于Spring 的开发</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413164508197.png" alt="image-20210413164508197"></p><ul><li>springboot<ul><li>一个快速开发脚手架</li><li>基于springboot可以快速开发单个微服务</li><li>约定大于配置</li></ul></li><li>springcloud<ul><li>基于springboot实现</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer47</title>
      <link href="/2021/04/13/jian-zhi-offer47/"/>
      <url>/2021/04/13/jian-zhi-offer47/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a>剑指 Offer 47. 礼物的最大价值</h2><p>本题是经典的动态规划思想解题，想得到的结果可以从上一个子问题推出。假设输入矩阵名为sum,长n,高 m.</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>dp数组，与输入矩阵等大</li></ul><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4><p>由题可知，矩阵中（i,j）位置只能从左（i - 1，j）和上（i, j - 1）抵达，自然推出递推公式为：</p><p>f(i , j) += Max(f (i - 1, j) , f (i , j -1))</p><p>当遍历指针位于第一行或者第一列时，不用考虑Max情况。</p><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>返回数组右下角的值。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：o(mn),因为要遍历所有矩阵值</p><p>空间复杂度：o(mn)因开辟等大dp数组</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>方法2在方法1的基础上简化，由于f(i ,j)只与前两个值有关，并且并不会使用到前面的值，则可以在原输入数组上进行原地修改，将空间复杂度简化为o(1)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-none"><code class="language-none">class Solution {    public int maxValue(int[][] grid) {       //初始化       int m = grid.length, n = grid[0].length;       for(int i = 0; i &lt; m; i++) {           for(int j = 0; j &lt; n; j++) {               if(i == 0 &amp;&amp; j == 0) continue;               else if(i == 0) {                   grid[i][j] += grid[i][j - 1];               }               else if(j == 0) {                   grid[i][j] += grid[i - 1][j];               }               else {                   grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]);               }           }       }       return grid[m - 1][n - 1];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方法执行内存分配初探</title>
      <link href="/2021/04/13/java-fang-fa-zhi-xing-nei-cun-fen-pei-chu-tan/"/>
      <url>/2021/04/13/java-fang-fa-zhi-xing-nei-cun-fen-pei-chu-tan/</url>
      
        <content type="html"><![CDATA[<h2 id="Java方法执行过程中的内存分配"><a href="#Java方法执行过程中的内存分配" class="headerlink" title="Java方法执行过程中的内存分配"></a>Java方法执行过程中的内存分配</h2><p>首先假设这样一个场景，新建了一个Java class文件，里面写了main方法和一些其他方法，现在我们要运行这个main函数。</p><p>在JVM虚拟机中，有一块方法区（内存区），首先会将main函数中设及到的类加载到这个方法区中。</p><p>在JVM虚拟机中，有一块堆内存（内存区）。</p><p>在JVM虚拟机中，有一块栈内存（内存区）。</p><p>加载了方法区后，程序依次调用方法，首先是main方法，那么main方法会在<strong>栈内存</strong>中分配空间，其中一些变量的内存会被加载在这个栈内存中这个空间某个区域。</p><p>依次执行编程语句，一旦程序调用新的方法，就又会在栈内存中为这个新方法分配独立的内存空间。</p><p>在执行中，存在不同语句中的参数调用，而java中参数调用采用值传递，具体操作是创造一个参数副本，赋值给新方法的参数内存区域。简而言之，方法操作参数操作的是传进来的值，在内存中的实现就是他不能操作这个被传入参数值在其他方法中的内存空间。</p><p>而return操作其实就是上面操作的逆行，在一个方法中创建的结果变量，按值传递给了另一个方法区的某个变量内存区。</p><p>代码：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413162745270.png" alt="image-20210413162745270"></p><p>图解：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413162723320.png" alt="image-20210413162723320"></p>]]></content>
      
      
      <categories>
          
          <category> JavaBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构(1)字符串与链表</title>
      <link href="/2021/04/13/redis-shu-ju-jie-gou-1-zi-fu-chuan-yu-lian-biao/"/>
      <url>/2021/04/13/redis-shu-ju-jie-gou-1-zi-fu-chuan-yu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p> 了解Redis字符串实现之前，先看看熟悉的C语言是怎么做的：</p><p>C语言用字符数组，数组末尾是一个空字符。</p><p>Redis的字符串是自己构建的，名字叫简单动态字符串，简称SDS，作为redis中默认字符串的表示。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>在redis中，一些不需要被更改的字符串会使用C字符串，比如一些打印日志。</li><li>而一旦需要更改字符串值，那么就会使用SDS了。</li><li>AOF模块中做缓冲区，客户端状态的输入缓冲区</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre class="line-numbers language-none"><code class="language-none">struct sdshdr{    //记录buf数组已使用的字节数量，等于SDS所保存的字符串长度    int len;    //buf数组未使用的变量    int free;    //字节数组，保存字符串    char [];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，free和字符串长度并没有直接关系。free为0代表着SDS没有为这个字符串分配未使用空间（额外空间）。len代表已使用空间，char[]数组依然保存了C的字符串惯例，末尾依旧是空字符串‘’\0“。</p><p>空字符串不计算在SDS的len属性里面，为空字符串额外分配一字节空间，和加到末尾，都是SDS函数自动完成的。</p><p>这样好处是，可以复用一些C语言操作字符串的函数。</p><h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><p>C语言使用N+1的字符数组来存储字符串长度为N 的字符串。</p><ul><li><p>常数复杂度获取字符串大小（直接查结构体成员变量len的值即可</p></li><li><p>C字符串不记录自身长度会，会带来缓冲区溢出的情况。比如内存中有两个字符串相邻，而一个小白程序员想要让前一个字符串拼接一个新的字符串，但是他忘了给这个前一个字符串后面分配额外空间，那么这个新字符串就会更改到邻接字符串上，也就是所说的溢出。</p></li><li><p>redis就不会出现这种情况，如果要拼接，就先检查SDS的空间够不够拼接之后存储，如果不够就自动拓展空间，够了就直接放进去。</p></li><li><p>减少内存重分配：比如添加或截断C字符串，都需要为这个底层的char数组分配或回收新的内存空间，内存重分配一般会进行系统调用，相对复杂，所以redis的SDS通过预存未使用空间来减少这种情况，并提出两种机制：</p><ol><li>空间预分配：应用于增长字符串操作。需要空间拓展时不仅为扩展部分开空间，还根据情况预分配新的空间。如果分配后小于1MB,则预分配和len属性同样大小的未使用空间。如果大于1MB则直接改为多预分配1MB未使用空间。</li><li>惰性空间释放：对应SDS字符串缩短操作。如果缩短，不立即回收这些内存，而是存入free属性值中。</li></ol></li><li><p>二进制安全：C字符串中的字符必须符合某种编码格式，如ASCII，字符串中不能包含”\0“，否则会被提前认为时结尾，这样导致其不能存储音频，视频和压缩文件这样的二进制数据。</p><p>而SDS确保了二进制安全，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组历到数据，这个buf属性并不能叫做字符数组，而应该叫做字节数组，因为保存的是一系列二进制数据。</p></li><li><p>最后是兼容部分C字符串函数，比如cmp比较等</p></li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表在Redis中的应用十分广泛，比如列表键的底层实现之一就是链表，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><p>Redis构建了自己的链表实现。</p><h2 id="链表和链表结点"><a href="#链表和链表结点" class="headerlink" title="链表和链表结点"></a>链表和链表结点</h2><pre class="line-numbers language-none"><code class="language-none">typedef struct listNode {    //前置结点    struct listNode *prev;    //后置结点    struct listNode *next;    //结点值    void *value;}listNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的时一个链表结点的组成，虽然仅仅用上面这个结构体两端指针互连其他结点就可以构造出链表，但是用另一个结构体封装起来比较方便使用。</p><pre class="line-numbers language-none"><code class="language-none">typedef struct list {   //表头结点   listNode *head;   //表尾结点   listNode *tail;   //链表包含的结点数量   unsigned long len;   //节点值复制函数   void *(dup) (void *ptr);   //节点值释放函数   void (*free) (void *ptr);   //节点值对比函数   int (*match) (void *ptr,void *key);}list;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个封装好的结构体中下面三个函数是为了实现多态链表的一些特定函数，dup函数复制链表结点保存值，free释放，match比较。</p><h2 id="链表特性"><a href="#链表特性" class="headerlink" title="链表特性"></a>链表特性</h2><ul><li>双端，有prev和next指针</li><li>无环，prev的和next都指向null</li><li>带表头指针和表尾指针，list结构中的head和tail指针，使得获取头尾结点时间复杂度为o（1）</li><li>链表长度计数器，得到链表长度不用遍历，时间复杂度o(1)</li><li>多态：链表结点使用void*指针来保存结点值，并且可以通过list结构中的dup，free，match三个属性为结点值设置类型特定函数，这意味着redis链表中可以保存不同数据类型的值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL概述</title>
      <link href="/2021/04/13/mysql-gai-shu/"/>
      <url>/2021/04/13/mysql-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql概述"><a href="#Mysql概述" class="headerlink" title="Mysql概述"></a>Mysql概述</h1><h2 id="Mysql的架构"><a href="#Mysql的架构" class="headerlink" title="Mysql的架构"></a>Mysql的架构</h2><p>mysql本身的架构为客户端/服务器架构。它的服务器程序直接和我们存储的数据打交道。然后可以由很多客户端连接到这个服务器上——服务器接收客户端的请求并相应它们。</p><p>同样，mysql的每个客户端都需要userid+password才能登录，登录后可以向服务器发送操作数据请求，服务端相应请求，或返回数据，或操作数据。</p><p>其实，mysql的服务器程序和客户端程序本质上就是对应两个不同的进程，代表着mysql服务器的进程又叫mysql数据库实例。</p><h2 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h2><h2 id="mysql启动"><a href="#mysql启动" class="headerlink" title="mysql启动"></a>mysql启动</h2><p>用服务的方式运行服务器程序。</p><p>在windows中，windows服务的概念是，如果一个程序在计算机上需要很长时间的运行，并且一旦开机就要启动它，那么一般这个程序会被注册为一个服务。我们也可以自己将一个程序注册为一个服务：</p><pre class="line-numbers language-none"><code class="language-none">"完整的可执行文件路径" --install [-manual][服务名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动服务：</p><pre class="line-numbers language-none"><code class="language-none">net start MySQL(注册的服务名)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭：start改为stop</p><p>启动客户端：</p><p>启动客户端一般要携带一些参数：</p><pre class="line-numbers language-none"><code class="language-none">mysql -h主机名 -u用户名 -p密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，还有一些方法可以让密码不在一行里被显示出来，也就是可以使用一些特殊命令让密码不在命令行显示，同样，关闭客户端程序也有相应的命令，只不过这个命令是在mysql命令根下运行的：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt;quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就能退出客户端了，但是切记这样并没有关闭服务端。</p><h2 id="客户端与服务器的连接过程"><a href="#客户端与服务器的连接过程" class="headerlink" title="客户端与服务器的连接过程"></a>客户端与服务器的连接过程</h2><p>其实客户端与服务器的交互本身是一个进程间的通信过程。mysql支持三种客户端和服务器的通信方式：</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>真实环境中，一般客户端和服务器并不在同一台主机上，那么它们之间必须通过网络进行通信。使用TCP，每个计算机有一个唯一IP地址，如果某个进程需要与其他进程通过网络进行链接，那么它会向操作系统申请一个端口号0~65535。那么网络中的其他进程就可以用ip+端口号来与这个进程进行通信。</p><p>同样，mysql作为一个网络中的进程，默认会申请3306这个端口号，其实通俗来说，mysql服务端监听3306这个端口。</p><p>如果服务端和客户端在同一个主机，可以用127.0.0.1来代表本机IP地址（计网233）。</p><p>总之想要访问，需要带服务端IP和监听的端口号，还得带上客户端用户的用户名和密码。</p><h3 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h3><p>进程间通信的相同方法，应该是差不多。windows比较能够使用。</p><h3 id="Unix域套接字文件"><a href="#Unix域套接字文件" class="headerlink" title="Unix域套接字文件"></a>Unix域套接字文件</h3><p>如果服务器和客户端都运行在同一台操作系统为类Unix，，可以尝试。</p><h2 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h2><p>其实不论客户端进程和服务器进程是采用哪种方式通信，最后实现效果：<strong>客户端进程向服务器进程发送一段Mysql语句，服务器进程处理后再向客户端发送一段含处理结果的文本</strong>。</p><p>服务器处理客户端请求的三个部分：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210408111205801.png" alt="image-20210408111205801"></p><h3 id="链接管理"><a href="#链接管理" class="headerlink" title="链接管理"></a>链接管理</h3><p>每当有一个客户端进程连接到服务器进程，服务器会创建一个线程来专门处理与这个客户端的交互。如果客户端断开，mysql的处理方式是不立即销毁线程，把它缓存起来，如果有新客户端就分配给它。同时，如果客户端和服务器不在一台主机，还会使用SSL来保证数据传输安全。还会限制同时链接客户端的数量。</p><h3 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h3><p>上面的结束之后，mysql服务器已经能获取到文本形式的请求，接着还要经过很多处理，比较重要的部分是查询缓存、语法解析、查询优化。</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>mysql会将刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接在缓存中找答案就好了。当然，似乎只能是查询请求才能被缓存。</p><p>两个查询请求在字符上不同，mysql 的缓存系统会检测设计到的每张表，如果出现了任何更改表结构或者数据的语句，所有的有关缓存都会无效并被高速缓存删除</p><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>那缓存没命中只能解析语句干活了呗。语句如果不正确就报错。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>一般我们的这个sql语句写的可能比较冗余，mysql优化程序会对我们的语句进行一个优化。优化的<strong>结果</strong>是生成一个计划，计划表明该用什么索引来查询，表之间的链接顺序是啥，我们可以使用explain语句来查看某个语句的执行计划。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>截止到现在都是在讨论方案，那真正存储数据的其实是存储引擎。mysql服务器把数据的存储和提取都封装到了一个存储引擎的模块。这个引擎做到了：</p><ul><li>物理逻辑上如何表示记录</li><li>从表中读取数据</li><li>怎么把数据写入到具体的物理存储器上</li></ul><p>mysql支持很多存储引擎，主要可以关注这些：</p><p>Innodb，MyISAM，Memory。而InnoDB是Mysql默认的存储引擎。</p><h1 id="启动选项和配置文件"><a href="#启动选项和配置文件" class="headerlink" title="启动选项和配置文件"></a>启动选项和配置文件</h1><p>mysql服务器提供了很多配置选项，我们可以通过更改这些配置选项，让我们的mysql适应不同的应用场景。简单介绍几个用命令行来更改设置的方法：</p><h2 id="禁用TCP-IP网络通信"><a href="#禁用TCP-IP网络通信" class="headerlink" title="禁用TCP/IP网络通信"></a>禁用TCP/IP网络通信</h2><pre class="line-numbers language-none"><code class="language-none">mysqld --skip-networking<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样做之后，如果再用127.0.0.1（本机IP访问）来访问服务器就会报错。</p><h2 id="改变表的默认存储引擎"><a href="#改变表的默认存储引擎" class="headerlink" title="改变表的默认存储引擎"></a>改变表的默认存储引擎</h2><pre class="line-numbers language-none"><code class="language-none">mysqld --default-storage-engine=MyISAM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样做之后，我们的表默认存储引擎会变为MyISAM。</p><p>每个mysql程序都有许多不同的选项。大多数程序提供了一个–help选项，你可以查看该程序支持的全部启动选项以及它们的默认值。</p><pre class="line-numbers language-none"><code class="language-none">mysql --help //mysql程序支持的启动选项mysqld_safe --help //mysqld_safe程序支持的启动选项mysqld --verbose --help //mysqld支持的启动选项（有些特别）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="长短形式"><a href="#长短形式" class="headerlink" title="长短形式"></a>长短形式</h3><p>每个命令可以有自己的短形式，可以叫他小名，命令行同样能识别</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413145711371.png" alt="image-20210413145711371"></p><h3 id="配置文件中使用选项"><a href="#配置文件中使用选项" class="headerlink" title="配置文件中使用选项"></a>配置文件中使用选项</h3><p>命令行中设置的东西只对当次启动生效。那每次启动都要设置岂不是麻烦死。为了让我们能够一次更改长久使用，更推荐使用配置文件的方式来设置启动选项。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>mysql程序启动时会寻找多个路径下的配置文件</p><p>windows：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413150035751.png" alt="image-20210413150035751"></p><ul><li>%WINDIR%是机器上windows的安装位置</li><li>BASEDIR是mysql安装路径</li><li>%APPDATA%表示Windows应用程序数据目录的值，可以使用下列命令查看： echo %APPDATA%</li></ul><p>UNIX：</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413150052218.png" alt="image-20210413150052218"></p><p>这说明计算机中这几个路径中的<strong>任意一个</strong>都可以作为配置文件。。</p><h3 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h3><p>每个启动选项都被分组，可以清晰的找到想配置的模块。</p><p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210413150323450.png" alt="image-20210413150323450"></p><ul><li>启动组中，修改配置文件的语法类似命令行，但是只能使用长形式。</li><li>清楚一个概念：一个启动命令会读取多个组的配置文件。</li><li>如果同一个命令访问多个组，那么以<strong>最后一个出现组中启动选项为准</strong>。</li><li><strong>通过启动选项设置的系统变量的作用范围都是GLOBAL的，也就是对所有客户端都有效的</strong></li></ul><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>为了让我们更好的了解服务器程序的运行情况，MySQL服务器程序中维护了好多关于程序运行状态的变量，它们被称为状态变量。</p><p>由于状态变量是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
