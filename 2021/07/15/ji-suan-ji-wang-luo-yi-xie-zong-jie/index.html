<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计网相关, Icedancemelody.blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计网相关 | Icedancemelody.blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Icedancemelody.blog" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Icedancemelody.blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Icedancemelody.blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计网相关</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/HTTP/">
                                <span class="chip bg-color">HTTP</span>
                            </a>
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                            <a href="/tags/TCP-UDP/">
                                <span class="chip bg-color">TCP/UDP</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/HTTP/" class="post-category">
                                HTTP
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-07-15
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    55 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="HTTP请求—响应报文"><a href="#HTTP请求—响应报文" class="headerlink" title="HTTP请求—响应报文"></a>HTTP请求—响应报文</h1><p>网页请求中，客户端发送HTTP请求报文，服务器解析报文，响应相应的返回值和数据组成的报文。</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><h3 id="请求行（GET-data-info-html-HTTP-1-1）"><a href="#请求行（GET-data-info-html-HTTP-1-1）" class="headerlink" title="请求行（GET /data/info.html HTTP/1.1）"></a>请求行（GET /data/info.html HTTP/1.1）</h3><ul>
<li>请求方法<ul>
<li>GET 用来请求访问已被 URI 识别的资源，指定的资源经服务器端解析后返回响应内容。</li>
<li>POST 方法用来传输实体的主体，主要目的并不是获取响应的主体内容</li>
<li>PUT 要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</li>
<li>DELETE DELETE 方法按请求 URI 删除指定的资源</li>
<li>可以指定请求的资源按期望产生某种行为</li>
</ul>
</li>
<li>请求URI</li>
<li>协议版本</li>
</ul>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><h4 id="Host：请求资源所在服务器"><a href="#Host：请求资源所在服务器" class="headerlink" title="Host：请求资源所在服务器"></a>Host：请求资源所在服务器</h4><ul>
<li>主机和端口号，它通常从HTTP URL中提取出来的</li>
<li>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</li>
<li>请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><ul>
<li>服务器接收到的Cookie信息</li>
<li>Cookie: status=enable</li>
<li>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。</li>
</ul>
<h4 id="Connection：连接的管理"><a href="#Connection：连接的管理" class="headerlink" title="Connection：连接的管理"></a>Connection：连接的管理</h4><ul>
<li>控制不再转发给代理的首部字段</li>
<li>管理持久连接<ul>
<li>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。</li>
<li>Connection: Keep-Alive/close表示建立长连接还是短连接，是否关闭连接</li>
</ul>
</li>
</ul>
<h4 id="Cache-Control：缓存的控制"><a href="#Cache-Control：缓存的控制" class="headerlink" title="Cache-Control：缓存的控制"></a>Cache-Control：缓存的控制</h4><ul>
<li>Cache-Control: no-cache</li>
<li>是为了防止从缓存中返回过期的资源</li>
<li>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</li>
<li>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</li>
</ul>
<h4 id="Range-客户端发请求"><a href="#Range-客户端发请求" class="headerlink" title="Range 客户端发请求"></a>Range 客户端发请求</h4><p>为并行下载以及断点续传提供了技术支持。</p>
<p>客户端发请求时对应的是<code>Range</code>，服务器端响应时对应的是<code>Content-Range</code></p>
<p>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p>
<blockquote>
<p>Range:(unit=first byte pos)-[last byte pos]</p>
</blockquote>
<p>Range: bytes=0-499 表示第 0-499 字节范围的内容<br>Range: bytes=500-999 表示第 500-999 字节范围的内容<br>Range: bytes=-500 表示最后 500 字节的内容<br>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容 </p>
<h4 id="Content-Range：服务器响应"><a href="#Content-Range：服务器响应" class="headerlink" title="Content-Range：服务器响应"></a>Content-Range：服务器响应</h4><p>Content-Range: bytes 5001-10000/10000</p>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>
<h3 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h3><p>通过一个空行，告诉服务器请求头部到此为止</p>
<h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><ul>
<li>若方法字段是GET，则此项为空，没有数据</li>
<li>若方法字段是POST，则通常来说此处放置的就是要提交的数据</li>
</ul>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><ul>
<li>协议版本、状态码及其描述</li>
<li>HTTP/1.1 200 OK</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><h4 id="Location：令客户端重新定向到的URI"><a href="#Location：令客户端重新定向到的URI" class="headerlink" title="Location：令客户端重新定向到的URI"></a>Location：令客户端重新定向到的URI</h4><ul>
<li>Location: <a target="_blank" rel="noopener" href="http://www.usagidesign.jp/sample.html">http://www.usagidesign.jp/sample.html</a></li>
<li>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</li>
<li>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。</li>
<li>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</li>
</ul>
<h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><ul>
<li>Set-Cookie: status=enable; expires=Tue， 05 Jul 2011 07:26:31</li>
<li>开始状态管理所使用的Cookie信息</li>
<li>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</li>
<li>expires 属性指定浏览器可发送 Cookie 的有效期<ul>
<li>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</li>
<li>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</li>
</ul>
</li>
</ul>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL全称：Uniform Resource Locator，又名统一资源定位符。与他关系密切的名词URI（Uniform Resource Identifier) 统一资源标识符。URI包含URL，URL在URI的基础上增加了定位能力（找到资源具体位置）。URI还包含URN（Uniform Resource Name）统一资源名称，顾名思义它只是个名字。</p>
<p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210416082336813.png" alt="image-20210416082336813"></p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
</tr>
<tr>
<td>HEAD</td>
<td>和GET方法类似，但不返回内容主体部分</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体（主要用来传输资源，GET是获取）</td>
</tr>
<tr>
<td>PUT</td>
<td>上传文件，没有权限限制，存在安全性问题，一般不用</td>
</tr>
<tr>
<td>PATCH</td>
<td>修改资源，但只能部分修改，会将原始资源完全被请求包含的修改资源替代</td>
</tr>
<tr>
<td>DELETE</td>
<td>和PUT相反，删除文件，同样没有权限机制</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>查询指定URL支持的方法</td>
</tr>
<tr>
<td>CONNECT</td>
<td>建立链接隧道，使用SSL和TLS协议把通信内容加密</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径，服务器会将通信路径返回</td>
</tr>
</tbody></table>
<p>GET和POST的区别</p>
<ul>
<li>GET一般是向服务器请求资源，POST把数据发送到后台使用</li>
<li>GET和POST都能使用额外参数，GET放在URL中，POST放在内容主体中。URL仅仅支持ASCII码，所以如果GET请求参数有中文，需要先编码，空格也是一样</li>
<li>GET安全POST不安全，GET安全因为它不会改变服务器的状态，但POST会改变，每一次POST请求会在服务器放上一条记录。</li>
<li>GET方法本身可以缓存，POST不能缓存</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以直到服务器端是正常处理了请求，还是出现了错误。</p>
<ul>
<li>1XX （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。</li>
<li>2XX    Success（成功状态码）    请求正常处理完毕<ul>
<li>200 OK：请求已正常处理</li>
<li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li>
</ul>
</li>
<li>3XX    Redirection（重定向状态码）    需要进行附加操作以完成请求</li>
<li>4XX    Client Error（客户端错误状态码）    服务器无法处理请求<ul>
<li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li>
<li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li>
<li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li>
<li>404 Not Found：服务器上没有请求的资源。路径错误等。没有发现文件、查询或URl</li>
</ul>
</li>
<li>5XX    Server Error（服务器错误状态码）    服务器处理请求出错<ul>
<li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li>
<li>501是服务器不支持的请求，无法完成请求</li>
<li>503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。 通常，这只是暂时状态。</li>
<li>505时服务器不支持请求的HTTP协议版本，无法完成处理</li>
</ul>
</li>
</ul>
<h1 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h1><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><ul>
<li><p>HTTP 1.0需要使用keep-alive参数来建立一个长连接，而HTTP1.1默认支持长连接，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</p>
</li>
<li><p>长连接的好处：一个网页上可能有多个资源对象，长连接可以通过一个连接传输网页上的所有对象，而短连接每次连接只能传输一个对象，也就是一个网页的内容需要传输多次</p>
</li>
<li><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<pre class="line-numbers language-none"><code class="language-none">Connection:keep-alive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>HTTP1.0缓存的资源对象到了一定时间之后会失效，不能再次使用；而HTTP1.1缓存的资源对象失效后还能与源服务器进行重新激活。</li>
<li>HTTP1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</li>
</ul>
<h2 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h2><ul>
<li>HTTP1.0一次只能请求一整个资源对象，而HTTP1.1可以请求一个资源对象的一部分，因此在不需要得到整个资源对象时，可节约带宽，而且支持断点续传</li>
<li>http 1.0 存在带宽浪费的现象，比方说，某时刻发送端 http 请求报文里有一个 token，但是这个 token 已经过期了，http 1.0 会把整个报文发送给接收端， 服务端看到报文是过期的，返回错误码 401，连接终止。</li>
<li>而HTTP1.1中客户端可以事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized），如果返回 401 则不再发送 body，否则再继续发送 body。</li>
</ul>
<h2 id="Host域"><a href="#Host域" class="headerlink" title="Host域"></a>Host域</h2><p>由于一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，因此HTTP1.1在HTTP1.0的基础上加了改进，加了一个Host域，用于指定共享同一个IP地址中的某一台主机，而HTTP1.0则默认一个IP地址只能属于一台主机，没有Host域</p>
<h1 id="DNS的运行过程（本地缓存-本地服务器-根服务器-顶级域名服务器）"><a href="#DNS的运行过程（本地缓存-本地服务器-根服务器-顶级域名服务器）" class="headerlink" title="DNS的运行过程（本地缓存-本地服务器-根服务器-顶级域名服务器）"></a>DNS的运行过程（本地缓存-本地服务器-根服务器-顶级域名服务器）</h1><ul>
<li>首先主机会查询DNS的本地缓存，如果没有则向其本地域名服务器发出DNS请求报文，这是递归查询。</li>
<li>本地域名服务器收到请求后，查询本地缓存，若没有记录，则以DNS客户的身份向根域名服务器发出解析请求。本地域名服务器向根域名服务器的查询是迭代查询</li>
<li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出查到的IP地址，要么告诉本地域名服务器：你下一步应当向哪个顶级域名服务器进行查询</li>
<li>本地域名服务器向顶级域名服务器发出解析请求报文，然后依次类推直到查询到该域名的IP地址</li>
<li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li>
</ul>
<h1 id="递归查询与迭代查询"><a href="#递归查询与迭代查询" class="headerlink" title="递归查询与迭代查询"></a>递归查询与迭代查询</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/858807-20170820124445615-743355102.png"></p>
<p> 一、主机向本地域名服务器的查询一般都是采用递归查询。</p>
<p>​    所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。</p>
<p>​    因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
<p>二、本地域名服务器向根域名服务器的查询的迭代查询。</p>
<p>​    迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p>
<p>​    然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。</p>
<p>​    顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。</p>
<p>​    最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机</p>
<h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><p>HTTP协议传输的数据都是未加密的，也就是明文的，所以用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能够加密传输，于是就有了SSL协议用于对HTTP协议传输的数据进行加密，从而诞生了HTTPS，简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议，要比HTTP协议安全</p>
<ul>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。</li>
<li>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
</ul>
<h1 id="HTTPS加密方式"><a href="#HTTPS加密方式" class="headerlink" title="HTTPS加密方式"></a>HTTPS加密方式</h1><p>HTTPS协议在内容传输的加密上使用的是对称加密，非对称加密只用在证书验证阶段</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h3><ul>
<li>又称为共享密钥加密算法。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密。这就要求加密和解密方事先都必须知道加密的密钥。</li>
<li>数据加密过程：在对称加密算法中，数据发送方将明文 (原始数据) 和加密密钥一起经过特殊加密处理 ，生成复杂的加密密文进行发送。</li>
<li>数据解密过程：数据接收方收到密文后，若想读取原数据，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>无需进行密钥交换的场景，如内部系统，事先就可以直接确定密钥</li>
<li>加解密速度快，适合数据内容比较大的加密场景</li>
</ul>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="认识-1"><a href="#认识-1" class="headerlink" title="认识"></a>认识</h3><ul>
<li>非对称加密算法，又称为公开密钥加密算法。它需要两个密钥，一个称为公开密钥(publickey)，即公钥，另一个称为私有密钥(privatekey)，即私钥。</li>
<li>因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。</li>
<li>如果使用公钥对数据进行加密，只有用对应的私钥才能进行解密。</li>
<li>如果使用私钥对数据进行加密，只有用对应的公钥才能进行解密。</li>
<li>例子：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥(私钥)，对加密后的信息进行解密。</li>
</ul>
<h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><ul>
<li>非对称加密中的加密算法是公开的，而密钥却是保密。公开密钥加密使用一对非对称的密钥。一把叫做私有密（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</li>
<li>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</li>
<li>要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</li>
<li>公钥是与私钥算法一起使用的密钥对的非秘密的一半。公钥和私钥匙通过一种算法得到的一个密钥对，其中一个向外界公开，称为公钥，另一个自己保留，称为私钥。通过这种算法得到的密钥对能保证在世界范围内是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，必须用另一个密钥解密。如果是用公钥加密数据就必须使用私钥揭秘，如果用私钥加密也必须用公钥揭秘，否则解密将不会成功。</li>
</ul>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>适用于需要密钥交换的场景，如互联网应用，无法事先约定密钥</li>
<li>与对称加密算法结合。利用非对称加密算法安全性较好的特点，传递对称加密算法的密钥。利用对称加密算法加解密速度快的特点，进行数据内容比较大的加密场景的加密。如HTTPS。</li>
</ul>
<h1 id="HTTPS通信流程"><a href="#HTTPS通信流程" class="headerlink" title="HTTPS通信流程"></a>HTTPS通信流程</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612226141_2.png" alt="img"></p>
<ul>
<li>客户端向服务器发起HTTPS请求，连接到服务器的443端口，并发送客户端支持的加密协议和版本，SSL、TLS</li>
<li>服务端从中筛选选择合适的加密协议</li>
<li>服务器将自己的证书发送给客户端。其中保护有公钥（服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。）</li>
<li>客户端收到服务器端的证书之后，会根据根证书对服务器发来的证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。（使用根证书验证证书的合法性）</li>
<li>客户端生成对称密钥，然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，将加密之后的客户端密钥发送给服务器。</li>
<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。然后服务器将加密后的密文发送给客户端。</li>
<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。整个HTTPS传输完成。</li>
</ul>
<h1 id="SSL证书的主要作用是什么？"><a href="#SSL证书的主要作用是什么？" class="headerlink" title="SSL证书的主要作用是什么？"></a>SSL证书的主要作用是什么？</h1><ol>
<li>实现数据加密传输，保证网站安全。信息传输过程中采用https加密方式，可以保证网站信息在传输过程中不被窃取和篡改，网站部署SSL证书后，浏览器和服务器之间的数据传输是密文传输的，可以有效保证双方的数据安全，有必要为网站配置SSL证书</li>
<li>验证服务器的身份，防止网站被钓鱼网站攻击。SSL证书可以进行严格的身份验证，SSL证书是证书颁发机构通过相应的身份验证审核而获得的，它可以有效的保护网站免受网络钓鱼网站的攻击，并验证网站的真正身份</li>
<li>消除浏览器的不安全提示的警告。用户浏览网站，有时会出现不安全的警告，但当SSL证书部署到网站后，不安全的警告就会消失，因为在SSL证书部署到网站之前，网站的信息传输是明文传输，很容易被第三方窃取，网站的安全得不到保证，用户很难信任网站，造成的损失也很大</li>
<li>提高网站关键词排名，搜索引擎一般会优先收录安装了SSL证书的网站。</li>
</ol>
<h1 id="HTTP无状态，怎么实现有状态（Session和Cookie）"><a href="#HTTP无状态，怎么实现有状态（Session和Cookie）" class="headerlink" title="HTTP无状态，怎么实现有状态（Session和Cookie）"></a>HTTP无状态，怎么实现有状态（Session和Cookie）</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。</li>
<li>上一次的请求对这次的请求没有任何影响，服务端也不会对客户端上一次的请求进行任何记录处理。</li>
<li>用户登录后，切换到其他界面，进行操作，服务器端是无法判断是哪个用户登录的。 每次进行页面跳转的时候，得重新登录。</li>
<li>既然HTTP协议是无状态的，不会记录用户信息，那么怎么样才能让HTTP协议记录用户信息呢？换句话说，服务器怎么判断发来HTTP请求的是哪个用户？</li>
<li>于是，两种用于保持HTTP状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。</li>
<li>cookie和session都是用来跟踪浏览器用户身份的会话方式。</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>cookie数据保存在客户端，session数据保存在服务端。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用session</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE</li>
<li>将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中</li>
</ul>
<h2 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h2><ul>
<li>cookie 机制采用的是在客户端保持状态的方案。</li>
<li>Cookie 是服务器生成的，但是发送给客户端，并且由客户端来保存。每次请求加上 Cookie就行了。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时，只需要从该 Session 中查找该客户的状态就可以了。</li>
<li>Session 保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。<strong>这是因为 Session 需要使用Cookie 作为识别标志。</strong>HTTP协议是无状态的，Session 不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id（即放在HTTP响应报文头部信息里的Set-Cookie）。Session依据该 Cookie 来识别是否为同一用户。</li>
</ul>
<h2 id="Cookie的工作原理"><a href="#Cookie的工作原理" class="headerlink" title="Cookie的工作原理"></a>Cookie的工作原理</h2><ul>
<li>浏览器端第一次发送请求到服务器端</li>
<li>服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端</li>
<li>浏览器端再次访问服务器端时会携带服务器端创建的Cookie</li>
<li>服务器端通过Cookie中携带的数据区分不同的用户</li>
<li>sessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。</li>
<li>如果你能够截获某个用户的cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用cookie被攻击的可能性比较大。如果cookie设置了有效值，那么cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有cookie，如果有的话，读取cookie，然后发送给服务器。</li>
</ul>
<h2 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h2><ul>
<li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端</li>
<li>浏览器端发送第N次请求到服务器端，浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID的Cookie的value(sessionId)去查询Session对象，从而区分不同用户。</li>
<li>简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</li>
</ul>
<p>session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出 cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含sessionid是，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的 session。这里需要注意的是session始终是有服务端创建的，并非浏览器自己生成的。但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现。</p>
<h2 id="基于-Token-的身份验证"><a href="#基于-Token-的身份验证" class="headerlink" title="基于 Token 的身份验证"></a>基于 Token 的身份验证</h2><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<ul>
<li>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。流程是这样的：</li>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
</ul>
<p><strong>例子</strong></p>
<ul>
<li>APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到APP，以后APP请求时，</li>
<li>凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。</li>
</ul>
<h1 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h1><ul>
<li>TCP面向连接，在通信双方进行通信之前，必须先建立连接、通信结束后必须释放这个连接；UDP采用无连接服务，通信前不需要连接。</li>
<li>TCP通过三次握手、确认、重传、拥塞控制等机制提供可靠传输服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达（可靠有序、不丢不重）；UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，即一次发送一个完整的报文，适合一次性传输少量数据的网络应用</li>
<li>每一条TCP连接只能是点到点的，不提供广播或多播服务；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li>
<li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。UDP一般用于即时通信（无拥塞控制），如QQ 语⾳、 QQ 视频 、直播、实时视频会议等</li>
</ul>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609468903_7.png" alt="img"></p>
<h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><ul>
<li>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li>
<li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li>
<li>确认标志位ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li>
<li>同步标志位SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li>
<li>终止标志位FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li>
</ul>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>三次握手是客户端和服务器连接建立的一种机制</li>
<li>三次握手主要目的是为客户端和服务端之间建立可靠的通信信道，即让通信双方确认自己与对方的发送与接收是正常的。</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>首先客户端向服务器端发送连接请求报文段<ul>
<li>标记位为SYN，表示“请求建立新连接”；</li>
<li>序号为seq=x（随机产生，x一般为1）；</li>
</ul>
</li>
<li>服务器端接收到来自客户端的TCP报文之后，服务器端为该TCP连接分配缓存和变量（发送缓存、接收缓存等），并向客户端返回确认报文段<ul>
<li>标志位为SYN=1，同意创建新连接</li>
<li>ACK=1，表示正确接收到客户端发送的信息，并让确认号ack有效</li>
<li>序号为seq=y(随机）</li>
<li>确认号为ack=x+1，表示确认收到客户端的序号seq，期望收到对方下一个报文段的第一个数据字节的序号x+1</li>
</ul>
</li>
<li>客户端接收到来自服务器端的确认收到数据的TCP报文之后，客户端为该TCP连接分配缓存和变量（发送缓存、接收缓存等），并向服务器端返回确认的确认，可以携带数据<ul>
<li>SYN=0</li>
<li>ACK=1</li>
<li>序号为seq=x+1</li>
<li>确认号为ack=y+1，表示收到服务器端序号seq，期望收到对方下一个报文段的第一个数据字节的序号为y+1</li>
</ul>
</li>
</ul>
<h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><ul>
<li>客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</li>
<li>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</li>
<li>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</li>
</ul>
<p>连接握手，握手的是<strong>通信双方数据原点的序列号</strong></p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/IAJB9TI6CQ~SC%7BP80$SSGH0.png" alt="IAJB9TI6CQ~SC{P80$SSGH0"></p>
<h1 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h1><p>攻击者发送TCP SYN，SYN是TCP三次握手的第一个数据包，而当服务器返回ACK后，该攻击者不对其进行确认，那这个TCP就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复的发送ACK给攻击者。这样更加浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都无法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p>
<p>SYN洪泛利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发送海量的请求连接的第一个握手包，被攻击服务器返回第二个握手包，因为对方是假冒IP，对方永远收不到包，并且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的半连接，并且会重试默认5次回应第二个握手包，大量的随机的恶意的SYN占满了未完成连接队列，导致正常合法的SYN排不上队列，让正常的业务请求连接不进来</p>
<h2 id="如何检测洪泛攻击？"><a href="#如何检测洪泛攻击？" class="headerlink" title="如何检测洪泛攻击？"></a>如何检测洪泛攻击？</h2><p>当你在服务器上看到大量的半连接状态的时候，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击，可以使用netstats命令来检测</p>
<h2 id="如何解决SYN攻击？"><a href="#如何解决SYN攻击？" class="headerlink" title="如何解决SYN攻击？"></a>如何解决SYN攻击？</h2><p>缩短超时时间</p>
<p>增加最大半连接数</p>
<p>SYN cookies技术：</p>
<p>当服务器接受到SYN报文段的时候，不直接为该TCP分配资源，接着会使用SYN报文段的源IP，目的IP，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号响应给客户端</p>
<p>如果客户端是正常连接，将会返回一个确认字段为cookie+1的报文段，接下来服务器会根据确认报文的源id，目的id，端口号以及秘密函数计算出一个结果，如果结果的值+1等于确认字段的值，就证明是刚刚请求连接的客户端，这时候才会为该TCP分配资源</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609469181_9.png" alt="img"></p>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>客户端打算关闭连接时，向服务器端发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接</li>
<li>标志位FIN = 1，seq = u </li>
<li>seq=u即前面已传送过的数据的最后一个字节的序号加一</li>
<li>全双工，所以TCP连接上有两条数据链路</li>
<li>发送FIN报文时，发送端不能再发送数据了，即关闭一条链路通路，但对方仍可以发送数据</li>
</ul>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li>ACK=1 seq = v， ack = u +1</li>
<li>服务器收到连接释放报文段则发出确认</li>
<li>自己的序号是ｖ，等于前面已传送过的数据的最后一个字节的序号加一</li>
<li>此时从客户端到服务器这个方向的连接释放了，TCP连接处于半关闭状态</li>
<li>但服务器若发送数据，客户端仍要接收，即从服务器到客户端这个方向的连接没有关闭</li>
</ul>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><ul>
<li>FIN=1，ACK=1，seq=ｗ，ack=u＋1</li>
<li>若服务器已经没有要向客户机发送的数据，就通知TCP释放连接</li>
<li>ack=u+1是因为从第一步连接释放后客户端没有再次发送数据，所以期待收到的下一个报文段第一个字节还是u+1</li>
</ul>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><ul>
<li>ACK=1，seq=u+1，ack=ｗ＋1</li>
<li>客户端收到连接释放报文段后，必须发出确认</li>
<li>此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL(最长报文段寿命）后，客户端才进入连接关闭状态</li>
</ul>
<h2 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手</h2><ul>
<li>关闭之所以不是三次而是四次主要是因为服务器端将”对客户端关闭报文的确认”和”关闭连接”两个操作分两次进行。</li>
<li>TCP是全双工的，它允许两个方向的数据传输被独立关闭。</li>
<li>当服务器端收到FIN报文时，所以只能先回复一个ACK确认报文，快速告知客户端，此关闭连接报文已经收到，此时从客户端到服务器这个方向的连接释放了，TCP连接处于半关闭状态。</li>
<li>但是服务器端向客户端是否需要继续传输数据由上层应用来决定，只有等到发送完了所有的数据后，服务器端才会发送一个FIN段来关闭此方向上的连接。</li>
<li>因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN和ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到服务器端所有的报文都发送完了，服务器才能发送FIN报文，因此不能一起发送。故需要四步握手。</li>
</ul>
<h2 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态</h2><ul>
<li>确保最后一个确认报文段能够到达。如果服务器端没收到客户端发送来的确认报文段，那么就会重新发送连接释放请求报文段，客户端等待一段时间就是为了处理这种情况的发生。</li>
<li>客户端会在第四次挥手时发送出对服务器端连接释放请求ACK之后进入到TIME_WAIT状态。客户端会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么客户端会重发ACK并再次等待2MSL。</li>
<li>如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。</li>
<li>2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。</li>
</ul>
<h1 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h1><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>TCP校验和覆盖TCP首部和TCP数据，是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p>
<h2 id="确认应答-序列号"><a href="#确认应答-序列号" class="headerlink" title="确认应答+序列号"></a>确认应答+序列号</h2><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>序列号是按顺序给发送数据的每一个字节都标上号码的编号，接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。使用序号字段保证数据能有序提交给应用层</p>
<p>排序技术：接收端保存当前按顺序收到的最后一个分组的序号，同时保存一个乱序到达的分组列表。当有分组到达时，如果是期待的下一个分组就递交给上一层，并检查列表看是否有其他分组也可以递交，乱序到达就加入列表中。</p>
<h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609471848_37.png" alt="img"></p>
<ul>
<li>确认字段是期待收到对方的下一个报文段的数据的第一个字节的序号</li>
<li>发送方缓冲区会继续存储那些已发送但未收到确认的报文段，以便需要时重传</li>
<li>接收方确定后发一个确认报文段。采用累计确认机制，即前面的必须都收到，不能留空</li>
</ul>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><ul>
<li>TCP每发送一个报文段，就对这个报文段设置一次计时器</li>
<li>计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段</li>
<li>使用自适应算法，动态改变重传时间RTTs(加权平均往返时间) </li>
<li>第一次只用第一个RTT，RTT是指在重发数据之前，等待确认应答到来的那个特定时间间隔，理论上是找到一个能保证确认应答一定能在这个时间内返回的最小时间。</li>
<li>RTTs取决于每一次的往返时间</li>
</ul>
<h3 id="冗余ACK"><a href="#冗余ACK" class="headerlink" title="冗余ACK"></a>冗余ACK</h3><ul>
<li>每当比期望序号大的失序报文段到达时，会发送冗余ACK，指明下一个期待字节的序号</li>
<li>冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认</li>
</ul>
<h3 id="快速重传技术"><a href="#快速重传技术" class="headerlink" title="快速重传技术"></a>快速重传技术</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1609472361_39.png" alt="img"></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，就根据自己接收缓存的大小，动态调整窗口字段rwnd给发送方，提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<p>发送方的发送窗口取决于窗口字段rwnd和拥塞窗口cwnd的最小值</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>当网络拥塞时，减少数据的发送。</p>
<h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><p>接收端处理数据的速度是有限的，如果发送方的速度太快会把缓冲区挤满，这个时候如果继续发送数据，就会导致丢包等一系列连锁反应，所以TCP支持<strong>根据接收端的能力来决定发送端的发送速度</strong>，这个机制就叫做流量控制。</p>
<p>流量控制的原理是，接收端将自己可以接受的缓冲区大小放入TCP首部中的窗口大小字段，通过ACK通知发送端，窗口大小字段越大说明网络的吞吐量越高。接收端一旦发现自己的缓冲区快满了，就会将窗口大小设定为一个更小的值通知给发送端；发送端接收到这个窗口后就会减慢自己的发送速度。如果接收端的缓冲区满了，就会将窗口设置为0，这时发送端不再发送数据，但是需要定期发送一个窗口探测数据段，使得接收端把窗口大小告诉发送端</p>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612221473_1.png" alt="img"></p>
<h2 id="背景-假设"><a href="#背景-假设" class="headerlink" title="背景/假设"></a>背景/假设</h2><ul>
<li>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。拥塞控制是为了降低整个网络的拥塞程度。</li>
<li>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<h2 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h2><ul>
<li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li>
<li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li>
<li>如果出现了超时（拥塞），则令 ssthresh = cwnd / 2，然后重新执行慢开始。</li>
</ul>
<h2 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h2><ul>
<li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li>
<li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</li>
<li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li>
<li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</li>
</ul>
<h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况叫做网络拥塞，对于拥塞的控制就叫做拥塞控制。TCP的拥塞控制算法包括慢启动，拥塞避免，快速重传，快速恢复。发送方维持一个叫做拥塞窗口的状态变量，它的值取决于网络的拥塞程度并且动态变化。在TCP双方建立连接的时候，拥塞窗口的值就被设置为1，还需要设置慢启动的阀值，在执行慢启动算法的时候，发送方每收到一个对新报文短的确认时，就把拥塞窗口的值增加，然后开始下一轮的传输，当拥塞窗口增长到慢启动阀值的时候，就使用拥塞避免算法</p>
<p>慢启动：刚开始的时候拥塞窗口数量是指数增长，当拥塞窗口的值超过慢启动阀值之后改用拥塞避免算法。也就是每个传输轮次，拥塞窗口只能线程加一。当发生超时重传，判断网络可能出现拥塞，将慢启动阀值更新为发生拥塞的拥塞窗口的一半，将拥塞窗口的值减少为1，并重新开始执行慢启动算法</p>
<p>快速重传：所谓快速重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传</p>
<p>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。发送方一旦收到3个连续的重复确认，就将报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。对于个别丢失的报文段，发送方不会超时重传，也就不会误以为出现了拥塞，进而降低拥塞窗口。发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢启动算法，而执行快恢复算法。快恢复实现是把开始的拥塞窗口值再增大一些，即等于新的慢开始的阀值</p>
<h1 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h1><p>网络五层协议包括物理层，数据链路层，网络层，传输层，应用层</p>
<p>物理层的作用是透明的传输比特流，物理层不对传输的比特流做任何处理，只是单纯的讲比特流从一个节点传到下一个节点。</p>
<p>数据链路层的作用是，在两个相邻节点之间传输数据的时候，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上透明的传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）在数据链路层透明的传输数据表示无论什么样的比特组合的数据都能够通过这个数据链路层</p>
<p>网络层的作用是，负责为分组交换网络上的不同主机提供通信服务，在发送数据时，网络层把传输层产生的报文段或用户数据封装成分组或者包进行传输。选中合适的路由，使得源主机传输层所传下来的分组，能够通过网络中的路由器找到目的主机。路由选择和分组转发。</p>
<p>传输层的作用是负责向两个主机进程之间的通信提供服务。</p>
<p>应用层的作用是直接向用户的应用进程提供服务</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2019020810542267.png"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层的任务是通过应用进程间的交互来完成特定网络应用。在互联网中应用层协议很多，如域名系统DNS，⽀持万维网应用的 HTTP协议，⽀持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 </p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>他将网络层的两个端系统之间的交付服务扩展到运行在两个不同端系统上的应用层进程之间的交付服务，称为运输层的多路复用与多路分解</p>
<p>运输层为运行在不同主机上的应用进程提供直接的通信服务</p>
<p>运输层的分组叫做报文段（传输单位是报文段或用户数据报）</p>
<p>UDP提供无连接服务，不提供不必要的服务，没有可靠性、流量控制、拥塞控制、重传机制</p>
<p>TCP提供可靠的、面向连接的服务</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，传输单位是数据报</p>
<p>路由选择与分组转发 最佳路径</p>
<p>实现路由选择、流量控制、差错控制、拥塞控制</p>
<p>根据特定的路由选择协议构造出路由表</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>链路层任务是将整个帧从一个网络元素移动到邻近的网络元素</p>
<p>数据链路层从网络层获得数据包，然后将这些数据包封装成帧，每个帧包含一个帧头部，一个有效载荷（用来存放数据包），以及一个帧尾。</p>
<p>为网络层提供服务、链路管理、成帧、差错控制、流量控制</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</p>
<p>如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去浪费网络资源。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>任务是实现相邻计算机节点之间透明的传输比特流（指不管所传数据是什么样的比特组合，都能传送），尽可能屏蔽掉具体传输介质和物理设备的差异。 </p>
<p>负责将帧中的一个个比特从一个节点移动到下一个节点，传输单位是比特</p>
<h1 id="OSI七层网络模型，并解释每一层的作用"><a href="#OSI七层网络模型，并解释每一层的作用" class="headerlink" title="OSI七层网络模型，并解释每一层的作用"></a>OSI七层网络模型，并解释每一层的作用</h1><p>OSI定义了网络互联的七层框架分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p>
<p>两台主机如果要实现通信，要经过很多的中间系统，也就是OSI七层的参考模型，每一层都需要用到。而中间系统只需要经过网络层，数据链路层和物理层。</p>
<p>每个对等层次之间都会有一个协议来规定两台主机都需要在这个层次实现一些相同的功能。</p>
<p>应用层是<strong>用户和网络的界面</strong>，是所有能和用户交互产生网络流量的程序。</p>
<p>表示层是用于处理在两个通信系统中交换信息的表示方式，通常是对语法和语义的处理</p>
<p>第一个功能是<strong>数据格式的变换</strong>，原因是不同主机之间的数据编码方式可能不太一样，所以为了使不同的主机能够进行数据的交换，所以需要表示层做一个翻译官的功能。比如说数据传过来的是一个比特流的形式，而我们需要看到的是一个图片，这时候就需要表示层发挥作用把比特流的格式转换为图片格式。</p>
<p>第二个功能是<strong>数据的加密和解密</strong>，这时候就需要表示层先对数据进行一个加密之后在放到链路上传输，在接收端进行解密。</p>
<p>第三个功能是<strong>数据的压缩和恢复</strong>，比如视频聊天的时候，视频聊天的图像非常大，我们需要对图像进行一个压缩然后再传输到链路上面，最后在接收端再把文件解压缩，呈现在屏幕上。</p>
<p>会话层是位于表示层下面的一个层次，表示层需要使用会话层的服务，会话层主要是先<strong>建立起一个连接</strong>，然后数据才能传过去。所以它的功能就是向表示层实体或者用户进行提供建立连接，并且在连接上与有序的传输数据。假如说我要访问两个网页，一个是百度，一个是看视频的，那我这个主机和这两个网络之间就建立起了一个同步，但是还没有进行数据的传输，假如我现在给视频点个快进，它应该马上就有个回应也就是画面往后几秒，而百度不会收到影响，这就是因为我这个主机和服务器建立的一个会话，是不会影响到会话的。会话层还有一个功能，就是<strong>使用校验点，使得会话在通信失效的时候从校验点继续恢复通信，实现数据同步。</strong>适用于传输大文件。</p>
<p>传输层是作为第一个面向端<strong>到端通信</strong>的层次，同时也是上面三层资源子网和下面三层通信子网之间的接口，传输层主要负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或者是用户数据报。</p>
<p>第一个功能是提供<strong>可靠传输，不可靠传输</strong>，可靠传输就是先将文件切成一个个报文段然后一个个的放在链路上传输，传输到接收端之后，接收端对于每一个报文段都会返回一个ACK，然后发送端收到确认信息之后再继续发送，如果没收到就重传。不可靠传输就是不需要建立连接，直接发送。</p>
<p>第二个功能是<strong>差错控制</strong>，比如说报文段顺序错了之类的</p>
<p>第三个功能是<strong>流量控制</strong>，让发送端的发送能力和接收端的接收速度匹配</p>
<p>第四个功能是<strong>复用和分用</strong>，复用指的是多个应用层进程可以同时使用下面传输层的服务，分用指的是传输层把收到的信息分别交付给上面应用层相应的进程。</p>
<p>网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机之间提供通信服务。传输单位是数据报，第一个功能是<strong>路由选择</strong>，就是选择合适的路由，通过相应的路由算法计算，选出最佳路径。</p>
<p>第二个功能是<strong>流量控制</strong>，就是协调发送端和接收端的速度</p>
<p>第三个功能是<strong>差错控制</strong>，就是发送端和接收端约定的一个规则，比如奇偶校验码之类的，接收端就需要检查我收到的分组是不是有错，如果有错就扔掉</p>
<p>第四个功能是拥塞控制，如果所有节点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此要采取一定措施，缓解这种拥塞</p>
<p>数据链路层主要任务是把网络层传下来的数据<strong>组装成帧</strong>，帧是数据链路层的传输单位，第一个功能是组装帧，定义帧的开始和结束。第二个功能是<strong>差错控制</strong>，包括帧错和位错，如果发现差错可能就会简单丢弃差错的帧。第三个功能是流量控制，第四个功能是<strong>介质访问控制</strong>，控制对信道的访问，如果在广播式网络中同一时间只能有一个人在发送信息，其他人都是处于监听状态，数据链路层就可以控制哪台主机可以占用信道。</p>
<p>物理层的任务就是在物理媒体上<strong>实现比特流的透明传输</strong>，传输单位是比特。透明传输指的是不管所传的数据是什么样的比特组合，都应当能在链路上传输。第一个功能是定义接口特性，比如引脚怎么接。第二个功能是定义传输模式，单工，半双工，双工。第三个功能是定义传输速率，我们说的百兆网啊啥的就是物理层定义的传输速率，第四个功能就是比特同步，我发了一个1，你就要收到一个1，第五个功能是比特编码，什么样的电压表示0什么样的电压表示1。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">icedancemelody</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://icedancemelody.com/2021/07/15/ji-suan-ji-wang-luo-yi-xie-zong-jie/">http://icedancemelody.com/2021/07/15/ji-suan-ji-wang-luo-yi-xie-zong-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">icedancemelody</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/HTTP/">
                                    <span class="chip bg-color">HTTP</span>
                                </a>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                                <a href="/tags/TCP-UDP/">
                                    <span class="chip bg-color">TCP/UDP</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">乐</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/07/15/ji-suan-ji-wang-luo-yi-xie-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="计网相关">
                        
                        <span class="card-title">计网相关</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/HTTP/" class="post-category">
                                    HTTP
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/HTTP/">
                        <span class="chip bg-color">HTTP</span>
                    </a>
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                    <a href="/tags/TCP-UDP/">
                        <span class="chip bg-color">TCP/UDP</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/07/15/nei-cun-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="操作系统回顾-内存管理">
                        
                        <span class="card-title">操作系统回顾-内存管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    操作系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                    <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                        <span class="chip bg-color">内存管理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">icedancemelody</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">81.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/icedancemelody" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1542975723@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1542975723" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1542975723" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
