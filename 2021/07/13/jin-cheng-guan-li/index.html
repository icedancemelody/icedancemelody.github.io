<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统回顾-进程管理, Icedancemelody.blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>操作系统回顾-进程管理 | Icedancemelody.blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Icedancemelody.blog" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Icedancemelody.blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Icedancemelody.blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统回顾-进程管理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                            <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                                <span class="chip bg-color">进程</span>
                            </a>
                        
                            <a href="/tags/%E7%BA%BF%E7%A8%8B/">
                                <span class="chip bg-color">线程</span>
                            </a>
                        
                            <a href="/tags/%E4%B8%AD%E6%96%AD/">
                                <span class="chip bg-color">中断</span>
                            </a>
                        
                            <a href="/tags/%E6%AD%BB%E9%94%81/">
                                <span class="chip bg-color">死锁</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                操作系统
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-13
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-07-13
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    56 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>为什么会有中断？</p>
<p>因为在早期，计算机执行程序的方式必须是串行的。程序放入计算机内存后需要等待其运行结束，才被移出内存。且每一道程序都是串行执行，这导致了系统资源利用率很低。</p>
<p>为了解决这个问题，首先人们先发明了操作系统，并引入了中断机制，其本质是：发生中断意味着需要操作系统介入，开展管理工作。中断机制涉及到的相关知识为：</p>
<ul>
<li>CPU会运行两种程序，一种是操作系统内核程序，一种是应用程序。分别对应CPU的两种态势：核心态和用户态。且CPU一般情况下是处于用户态运行应用程序。</li>
<li>发生中断后，操作系统介入，且CPU立即转变为核心态。</li>
<li>当中断发生后，当前CPU正在运行的进程会停止运行（挂起），CPU转为处理中断请求。</li>
</ul>
<h2 id="CPU处理中断的过程"><a href="#CPU处理中断的过程" class="headerlink" title="CPU处理中断的过程"></a>CPU处理中断的过程</h2><p>CPU在用户态运行的好好的，它什么时候会发现有打断它正常工作的突发事件呢？</p>
<ul>
<li>CPU通常在用户态下按顺序执行用户程序的每条指令，执行完每条指令后，CPU都会检查当前是否有外部中断信号，没有则继续执行指令。</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（程序状态字PSW、程序计数器PC、通用寄存器等）</li>
</ul>
<h2 id="核心态-gt-用户态"><a href="#核心态-gt-用户态" class="headerlink" title="核心态->用户态"></a>核心态-&gt;用户态</h2><ul>
<li>一般情况下，操作系统内核会把CPU的使用权主动让给应用程序，即转变为用户态。(只要我不用，一般它都是用户的)</li>
<li>执行一条特权指令——修改程序状态字PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li>
</ul>
<h2 id="用户态-gt-核心态"><a href="#用户态-gt-核心态" class="headerlink" title="用户态->核心态"></a>用户态-&gt;核心态</h2><ul>
<li>中断一旦出现，硬件自动转变为核心态，操作系统带着中断程序抢占CPU使用权</li>
<li>中断是让操作系统内核夺回CPU使用权的<strong>唯一途径</strong></li>
</ul>
<p>那么哪些发生的事件属于中断呢？</p>
<h2 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h2><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>内中断与当前执行的指令有关，中断信号来源于CPU内部，也称为异常。</p>
<p>这种异常主要可分为三类：</p>
<ul>
<li>陷入：由陷入指令引发，是应用程序故意引发的，有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的</li>
<li>故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行。例如缺页故障。</li>
<li>终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。若当前执行的指令是非法的，则会引发一个中断信号。例如执行除法指令时发现除数为 0、试图在用户态下执行特权指令</li>
</ul>
<h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><ul>
<li>与当前执行的指令无关，中断信号来源于CPU外部</li>
<li>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</li>
<li>例如：时钟中断——由时钟部件发来的中断信号、IO中断请求</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用就是刚刚的内中断中的陷入指令，其主要出现情况是用户态程序想要借助操作系统内核实现一些特殊功能。这是一种由用户态程序自包含的一种请求使用操作系统功能服务的指令。</p>
<ul>
<li>运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能则要用到系统调用</li>
<li>运行的用户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</li>
<li>由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li>
<li>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</li>
</ul>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>在发起系统调用指令后，CPU对系统调用的执行过程为：</p>
<ul>
<li>传递系统调用参数-&gt; 执行陷入指令（用户态）-&gt; 执行相应的内请求核程序处理系统调用（核心态）-&gt; 返回应用程序</li>
<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>陷入指令 = trap 指令 = 访管指令</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>程序段</li>
<li>数据段</li>
<li>进程控制块（PCB)<ul>
<li>操作系统对进程进行管理所需要的信息都在PCB中</li>
<li>当OS要调度某进程执行时，要从PCB中查看其状态以及其优先级</li>
<li>当调度到某个进程后，要根据其PCB中保存的处理机状态信息，设置该进程恢复运行的现场。</li>
<li>包括进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息等。</li>
</ul>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>创建：进程正在被创建，创建程序段、数据段、PCB信息</li>
<li>就绪：进程创建好了，并被操作系统分配了除了CPU处理机之外的一切其他资源（内存，I/O设备等）。一旦得到处理机资源（处理机分配的时间片）既可以运行</li>
<li>运行：进程正在处理机上运行（单核CPU下，任意时刻只有一个进程处于运行状态）。</li>
<li>阻塞：又称为等待，进程正在等待某一事件而暂停运行，如等待某资源可用或等待IO操作完成。即使处理机是空闲的，该进程也不能运行</li>
<li>结束：进程正在从系统中消失，可能时进程正常结束，也可能是其他原因中断退出运行。</li>
<li>就绪挂起，挂起态是将进程映像调到外存，阻塞态进程映像还在内存中</li>
<li>阻塞挂起</li>
</ul>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>每一个进程是资源分配的基本单位。</p>
<p>进程结构由以下几个部分组成：代码段，堆栈段，数据段。</p>
<ul>
<li><p>代码段是静态的二进制代码</p>
</li>
<li><p>堆栈段</p>
<p>　1. 为函数内部的局部变量提供存储空间。</p>
<p>  　2. 进行函数调用时，存储“过程活动记录”。</p>
<p> 　3. 用作暂时存储区。如计算一个很长的算术表达式时，可以将部分          计算结果压入堆栈。</p>
<p>栈区（stack）：由编译器自动分配释放 ，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。<br>堆区（heap）：由程序员分配释放， 若程序员不释放，程序结束时可能由操作系统回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 </p>
</li>
<li><p>数据段</p>
<p>包括BSS段（Block Started by Symbol）的数据段。BSS段存储未初始化或初始化为0的全局变量、静态变量，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。数据段存储经过初始化的全局和静态变量。</p>
</li>
</ul>
<p>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。</p>
<p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p>
<p>如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p>
<p>我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有堆栈。 　　</p>
<p>让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 　　　　</p>
<p>在切换时，一个进程存储在处理器各寄存器中的中间数据叫做<strong>进程的上下文</strong>，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存储在<strong>进程的私有堆栈</strong>中的。 　 </p>
<p>　　显然，进程的切换可以用<strong>中断技术</strong>来实现，即当调度器获得了待运行进程的控制块之后，应立即用软中断指令来中止当前进程的运行，并保存当前进程的PC值和PSW值。其后，使用压栈指令把处理器其他寄存器的值压入进程私有堆栈。接下来，就从待运行进程的进程控制块中取出<strong>私有堆栈指针的值并存入处理器的寄存器SP</strong>，至此SP就指向了待运行进程的私有堆栈，于是下面就自待运行进程的私有堆栈中弹出上下文进入处理器。最后，利用中断返回指令来实现自待运行进程的私有堆栈中弹出PSW值和自待运行进程的 私有堆栈中弹出PC值的功能。 　　</p>
<p>这是一个完整的软中断处理过程，只不过在保护现场和恢复现场工作中，保护的是被中止运行进程的现场，恢复的是待运行进程的现场，这一切都依赖于堆栈指针的切换。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>切出： 一个线程被剥夺处理器的使用权而被暂停运行<br>切入： 一个线程被系统选中占用处理器开始或继续运行</p>
<p>上下文，一般包括<strong>通用寄存器和程序计数器</strong>的内容。在切出时，操作系统会将线程的进度信息保存到内存。在切入时，操作系统需要从内存中加载线程的上下文。</p>
<p>在单核cpu中，多线程的执行是通过cpu的时间片分配，每个线程会分配到一个时间片，循环执行这些线程，线程时间片消耗完了就会进入等待状态，直到分配到新的时间片，因为时间片的时间非常短，所以cpu不停的切换线程执行，给我们造成了多线程同时运行的错觉。</p>
<p>cpu通过时间片循环执行线程任务，当线程的cpu时间片用完后会保存当前任务状态，方便下次获取到cpu时间片的时候能继续执行，当下次分配时间片后执行到该线程时，会重新加载该线程的任务状态，而这个从保存任务状态到重新加载的过程就叫上下文换。</p>
<p>在进程A切换到进程B的过程中，先保存A进程的上下文，以便于等A恢复运行的时候，能够知道A进程的下一条指令是啥。然后将要运行的B进程的上下文恢复到寄存器中。这个过程被称为上下文切换。上下文切换开销在进程不多、切换不频繁的应用场景下问题不大。但是现在Linux操作系统被用到了高并发的网络程序后端服务器。在单机支持成千上万个用户请求的时候，这个开销就得拿出来说道说道了。因为用户进程在请求Redis、Mysql数据等网络IO阻塞掉的时候，或者在进程时间片到了，都会引发上下文切换。</p>
<p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p>
<p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p>
<p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021-2-27-1.png" alt="2021-2-27-1"></p>
<h2 id="fork系统调用过程"><a href="#fork系统调用过程" class="headerlink" title="fork系统调用过程"></a>fork系统调用过程</h2><p>fork()系统调用用于创建新进程，新创建的进程为<strong>子进程</strong>，调用fork()并创建新进程的进程是<strong>父进程</strong>。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程</p>
<p>子进程创建后，系统会给子进程分配资源，然后把原来的进程的所有值都复制到新的子进程中，只有少数值与原来的进程的值不同；其实就是父进程的一份<strong>副本</strong>。但是子进程和父进程驻留在不同的内存空间上。这些内存空间具有相同的内容，并且一个进程执行的任何操作都不会影响其他进程，进程间彼此是数据隔离的。</p>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><p>进程：进程是程序的⼀次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，而 main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p>
</li>
<li><p>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
</li>
<li><p>线程：但线程是⼀个比进程更小的执行单位。⼀个进程在其执行的过程中可以产生多个线程，线程也被称为轻量级进程。多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
</li>
<li><p>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</p>
</li>
</ul>
<p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程是多条线程共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p>
<p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小。</p>
<p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<h2 id="线程切换时机"><a href="#线程切换时机" class="headerlink" title="线程切换时机"></a>线程切换时机</h2><ul>
<li>CPU时间片用完</li>
<li>垃圾回收</li>
<li>更高优先级线程运行</li>
<li>线程自己调用sleep，yield，wait，join，park，synchronized，lock</li>
</ul>
<h2 id="线程切换过程"><a href="#线程切换过程" class="headerlink" title="线程切换过程"></a>线程切换过程</h2><p>如果现在有两个并发的线程：外壳线程和hello线程。<br>　　开始只有外壳进程在运行，即等待命令行上的输入，当我们让他运行hello程序时，外壳通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。<br>　　操作系统保存外壳线程的上下文，创建一个新的hello线程及其上下文，然后将控制权传递给新的hello进程。<br>　　hello线程终止后，操作系统恢复外壳线程的上下文，并将控制权传回给他，外壳线程将继续等待下一个命令行输入。</p>
<h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><h3 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h3><ul>
<li><p>1：1实现</p>
</li>
<li><p>由内核完成线程切换</p>
</li>
<li><p>一般使用内核线程的高级接口-轻量级进程</p>
</li>
<li><p>即使其中某个轻量级进程在系统调用中被阻塞，也不会影响整个进程继续工作</p>
</li>
<li><p>缺点是轻量级进程要消耗一定的内核资源，线程操作需要系统调用</p>
</li>
<li><p>Java线程模型基于操作系统原生线程模型实现，即1：1线程模型</p>
</li>
<li><p>每一个Java线程都是直接映射到一个操作系统原生线程来实现，HotSpot不干涉线程调度，交给操作系统管理</p>
<p>Java虚拟机的线程模型基于操作系统原生线程模型来实现，每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以Java虚拟机自己是不会去干涉线程调度的(可以设置线程优先级给操作系统提供调度建议)，全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p>
<p>操作系统支持怎样的线程模型，在很大程度上会影响上面的Java虚拟机的线程是怎样映射的。线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是完全透明的。</p>
</li>
</ul>
<h3 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h3><ul>
<li>1：N实现</li>
<li>完全建立在用户空间的线程库上，系统内核不能感知用户线程的存在</li>
<li>完全由用户态完成，不需要切换到内核态</li>
<li>一般不支持用户线程</li>
</ul>
<h3 id="用户线程和轻量级进程混合实现"><a href="#用户线程和轻量级进程混合实现" class="headerlink" title="用户线程和轻量级进程混合实现"></a>用户线程和轻量级进程混合实现</h3><ul>
<li>N:M实现</li>
<li>用户线程还是完全建立在用户空间中，可以支持大规模的用户线程并发</li>
<li>操作系统支持的轻量级进程作为用户线程和内核线程之间的桥梁</li>
</ul>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="协同式"><a href="#协同式" class="headerlink" title="协同式"></a>协同式</h3><ul>
<li>执行时间由线程本身来控制，实现简单，切换操作对自己可知，没有线程同步问题</li>
<li>线程执行时间不可控制，如果坚持不让处理机，可能系统崩溃</li>
</ul>
<h3 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h3><ul>
<li>由系统分配执行时间，线程切换不受线程本身决定</li>
<li>线程执行时间可控</li>
<li>线程调度虽然是系统自动完成，但可以设置线程优先级来建议操作系统</li>
<li>线程优先级不稳定，因为java线程是被映射到系统的原生线程上来实现的，可能某些操作系统实际优先级与java的不能一一对应，优先级还可能被系统自行改变</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p>
<p><strong>做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p>
<p>作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p>
<h2 id="多线程优势与弊端"><a href="#多线程优势与弊端" class="headerlink" title="多线程优势与弊端"></a>多线程优势与弊端</h2><p>原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p>
<p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/2021_2_17_3.png" alt="2021_2_17_3"></p>
<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>1、（中断／异常等触发）正向模式切换并压入PSW／PC 。 （Program Status Word 程序状态字。program counter 程序计数器。指向下一条要执行的指令）</p>
<p>2、保存被中断进程的现场信息。</p>
<p>3、处理具体中断、异常。</p>
<p>4、把被中断进程的系统堆栈指针SP值保存到PCB。（Stack Pointer 栈指针。Process Control Block 进程控制块。）</p>
<p>5、调整被中断进程的PCB信息，如进程状态）。</p>
<p>6、把被中断进程的PCB加入相关队列。</p>
<p>7、选择下一个占用CPU运行的进程。</p>
<p>8、修改被选中进程的PCB信息，如进程状态。</p>
<p>9、设置被选中进程的地址空间，恢复存储管理信息。</p>
<p>10、恢复被选中进程的SP值到处理器寄存器SP。</p>
<p>11、恢复被选中进程的现场信息进入处理器。</p>
<p>12、（中断返回指令触发）逆向模式转换并弹出PSW／PC。</p>
<h3 id="切换时机"><a href="#切换时机" class="headerlink" title="切换时机"></a>切换时机</h3><p>进程切换一定发生在中断／异常／系统调用处理过程中，常见的有以下情况：</p>
<p>1、阻塞式系统调用、虚拟地址异常。</p>
<p>导致被中断进程进入等待态。</p>
<p>2、时间片中断、I/O中断后发现更改优先级进程。</p>
<p>导致被中断进程进入就绪态。</p>
<p>3、终止用系统调用、不能继续执行的异常。</p>
<p>导致被中断进程进入终止态。</p>
<h3 id="进程上下文切换开销"><a href="#进程上下文切换开销" class="headerlink" title="进程上下文切换开销"></a>进程上下文切换开销</h3><p>一种是直接开销、一种是间接开销。</p>
<p>直接开销就是在切换时，cpu必须做的事情，包括：</p>
<ul>
<li><p>切换页表全局目录</p>
</li>
<li><p>切换内核态堆栈</p>
</li>
<li><p>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p>
</li>
<li><ul>
<li>ip(instruction pointer)：指向当前执行指令的下一条指令<pre><code>- bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址
    - sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址
    - cr3:页目录基址寄存器，保存页目录表的物理地址
</code></pre>
</li>
</ul>
</li>
<li><p>刷新TLB</p>
</li>
<li><p>系统调度器的代码执行</p>
</li>
</ul>
<p>间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。</p>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="高级调度-作业调度"><a href="#高级调度-作业调度" class="headerlink" title="高级调度/作业调度"></a>高级调度/作业调度</h2><ul>
<li>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</li>
<li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。</li>
<li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li>
<li>无-&gt;创建态-&gt;就绪态</li>
</ul>
<h2 id="中级调度-内存调度"><a href="#中级调度-内存调度" class="headerlink" title="中级调度/内存调度"></a>中级调度/内存调度</h2><ul>
<li>决定将哪个处于挂起状态的进程重新调入内存。</li>
<li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li>
<li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。提高内存利用率和系统吞吐量</li>
<li>暂时调到外存等待的进程状态为挂起状态。PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息被挂起的进程PCB会被放到的挂起队列中。</li>
<li>挂起态-&gt;就绪态</li>
</ul>
<h2 id="低级调度-进程调度"><a href="#低级调度-进程调度" class="headerlink" title="低级调度/进程调度"></a>低级调度/进程调度</h2><ul>
<li><p>按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
</li>
<li><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p>
</li>
<li><p>进程调度的频率很高，一般几十毫秒一次。</p>
</li>
<li><p>从内存调入CPU，从就绪态-&gt;运行态</p>
</li>
</ul>
<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="非交互式进程调度算法"><a href="#非交互式进程调度算法" class="headerlink" title="非交互式进程调度算法"></a>非交互式进程调度算法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>不关心“响应时间”，也并不区分任务的紧急程度</li>
<li>适合用于早期的批处理系统</li>
<li>法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li>
<li>对于用户来说，交互性很糟糕</li>
</ul>
<h3 id="先到先服务-FCFS"><a href="#先到先服务-FCFS" class="headerlink" title="先到先服务(FCFS)"></a>先到先服务(FCFS)</h3><ul>
<li>从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li>
<li>非抢占式的算法</li>
</ul>
<h3 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h3><ul>
<li>从就绪队列中选出⼀个估计运行时间最短的进程为之分配资源，使它⽴即执行并⼀直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>非抢占式</li>
<li>每次调度时选择当前已到达且运行时间最短的作业</li>
<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li>对短作业有利，对长作业不利。</li>
<li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。</li>
<li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。当一个进程完成时也需要调度</li>
</ul>
<h3 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h3><ul>
<li>Highest Response Ratio Next</li>
<li>综合考虑作业/进程的等待时间和要求服务的时间</li>
<li>非抢占式</li>
<li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li>
<li>响应比=（等待时间+要求服务时间）/要求服务时间</li>
<li>只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</li>
</ul>
<h2 id="交互式进程调度算法"><a href="#交互式进程调度算法" class="headerlink" title="交互式进程调度算法"></a>交互式进程调度算法</h2><h3 id="时间片轮转（RR，-Round-Robin）"><a href="#时间片轮转（RR，-Round-Robin）" class="headerlink" title="时间片轮转（RR， Round-Robin）"></a>时间片轮转（RR， Round-Robin）</h3><ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</li>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li>
<li>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
</ul>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><ul>
<li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li>
<li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度；当就绪队列发生改变时也需要检查是会发生抢占</li>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>
<li>若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
<li>对其他调度算法的折中权衡</li>
<li>UNIX 操作系统采取的便是这种调度算法。</li>
<li>抢占式的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li>
<li>对各类型进程相对公平（FCFS的优点）</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）</li>
<li>短进程只用较少的时间就可完成(SPF优点)</li>
<li>不必实现估计进程的运行时间（避免用户作假）</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</li>
<li>会导致饥饿</li>
</ul>
<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul>
<li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</li>
<li>为了安全，一个进程不能直接访问另一个进程的地址空间</li>
<li>任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核</li>
<li>在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</li>
</ul>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ol>
<li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系<strong>通常是指父子进程关系</strong>。把前一条命令的输出作为后一条命令的输入</li>
<li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>消息队列MessageQueue：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存SharedMemory：<strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li>信号量Semaphore：信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，实现进程、线程的对临界区的同步及互斥访问。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
<li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li>
</ol>
<h2 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h2><ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，<strong>操作系统内核</strong>专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种<strong>同步机制（如信号量）</strong>来达到进程间的同步及互斥。</li>
<li>操作系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制</li>
<li>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</li>
<li>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，因为把同一块物理内存的地址空间映射到不同进程的地址空间当中，那么不同的进程之间通信，通过直接修改地址空间当中的内存即可，该机制的实现只需要两次拷贝即可实现，不需要像其它的进程通信机制那样将数据从用户空间拷贝到内核，然后在从内核拷贝到用户空间，实行四次拷贝操作，因此使用共享内存通信比较高效。使用共享内存的话，需要对共享的进程对共享内存的访问进行同步，防止访问对于共享数据的破坏。</li>
</ul>
<p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p>
<p>采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，<strong>则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong></p>
<p><img src="https://ice-tongji.oss-cn-beijing.aliyuncs.com/img/image-20210713184510555.png" alt="image-20210713184510555"></p>
<p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p>
<h2 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h2><ul>
<li>信号量是⼀个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。</li>
<li><strong>解决共享内存多进程竞争内存的问题</strong></li>
<li>信号量是一个计数器，可以用来控制多个线程对共享资源的访问。它不是用于交换大批数据，而用于多线程之间的同步。它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul>
<li>管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。</li>
<li>匿名管道是单向的，只能在有亲缘关系的进程间通信有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li>无名管道阻塞问题： 无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li>
<li>有名管道阻塞问题： 有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li>
<li>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</li>
<li>通信方式效率低下，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</li>
<li>管道不适合频繁通信的进程</li>
<li>各进程要互斥地访问管道</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li>
<li>如果没写满，就不允许读。如果没读空，就不允许写。</li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li>
</ul>
<h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><ul>
<li>netstat -tulnp | grep 8080</li>
<li>把前一条命令的输出作为后一条命令的输入</li>
<li>如果两个进程要进行通信的话，就可以用这种管道来进行通信</li>
<li>这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道</li>
<li>这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>管道是半双工的，数据只能向一个方向流动需要双方通信时，需要建立起两个管道。</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>
</ul>
<p><strong>实质</strong></p>
<ul>
<li>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</li>
<li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li>
</ul>
<p><strong>局限</strong></p>
<ul>
<li>只支持单向数据流</li>
<li>只能用于具有亲缘关系的进程之间</li>
<li>没有名字</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）</li>
<li>管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</li>
</ul>
<h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><ul>
<li>它提供了一个路径名与之关联</li>
<li>有名管道的文件形式存在于文件系统中 ，这样， 即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信 ，因此，通过有名管道不相关的进程也能交换数据。</li>
<li>严格遵循先进先出(first in first out)，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 有名管道的名字存在于文件系统中，内容存放在内存中。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">mkfifo  test #创建了一个名字为 test 的命名管道
echo "this is a pipe" &gt; test   // 写数据
//用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来
//这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束
cat &lt; test  // 读数据 test 里面的数据被读取出来了。上一条命令也执行结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h2><ul>
<li><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p>
</li>
<li><p>把进程的数据放在某个内存之后就马上让进程返回，无需等待其他进程来取</p>
</li>
<li><p>a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的</p>
</li>
<li><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p>
</li>
<li><p>存放在内核中，只有在内核重启(操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p>
</li>
<li><p>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p>
</li>
<li><p>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识.</p>
</li>
<li><p>消息队列允许一个或多个进程向它写入与读取消息</p>
</li>
<li><p>管道和消息队列的通信数据都是先进先出的原则。</p>
</li>
<li><p>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比FIFO更有优势。</p>
</li>
<li><p>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</p>
</li>
<li><p>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p>
</li>
</ul>
<h2 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h2><ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
<li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></li>
</ul>
<h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><ul>
<li>解决两个相隔几千里的进程能够进行通信</li>
<li>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</li>
<li>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
<li>特性由3个属性确定，它们分别是：域、端口号、协议类型。</li>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密，数据安全性强</li>
</ul>
<h1 id="线程间同步机制"><a href="#线程间同步机制" class="headerlink" title="线程间同步机制"></a>线程间同步机制</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p><strong>通过对多线程的串行化来访问公共资源或一段代码</strong>，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>采用互斥对象机制。 <strong>只有拥有互斥对象的线程才有访问公共资源的权限</strong>，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>
<p> 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以<strong>跨越进程使用</strong>。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>它允许多个线程在同一时刻访问同一资源，但是需要<strong>限制在同一时刻访问此资源的最大线程数目</strong> 。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p>
<p>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p> <strong>通过通知操作的方式</strong>来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 </p>
<h1 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">do</span>
<span class="token punctuation">{</span>
    <span class="token comment">//进入区 负责实现互斥的代码段 负责检查是否可进入临界区，可以则上锁</span>
    <span class="token comment">//临界区 临界区是进程中访问临界资源的代码段</span>
    <span class="token comment">//退出区 负责实现互斥的代码段 负责解锁</span>
    <span class="token comment">//剩余区 做其他处理</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>称间接制约关系</li>
<li>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</li>
<li>把一个时间段内只允许一个进程使用的资源称为临界资源</li>
<li>对临界资源的互斥访问</li>
</ul>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><ul>
<li>两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象</li>
<li>哲学家进餐问题：每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源</li>
<li>当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么他们就会永远被阻塞</li>
</ul>
<h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。</li>
<li>不可剥夺条件：进程所获得的资源在未使用完之前， 不能由其他进程强行夺走 ，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源 ，但又提出了新的资源请求 ，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链 ，链中每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<h2 id="死锁发生"><a href="#死锁发生" class="headerlink" title="死锁发生"></a>死锁发生</h2><ul>
<li>对不可剥夺资源的不合理分配，可能导致死锁</li>
<li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><ul>
<li>把只能互斥使用的资源改造为允许共享使用</li>
<li>SPOOLing技术</li>
<li>并不是所有的资源都可以改造程可共享使用的资源</li>
</ul>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ul>
<li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时，再重新申请。</li>
<li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保持和恢复状态的资源</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这种情况，就会导致进程饥饿</li>
</ul>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul>
<li>采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源</li>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li>
</ul>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul>
<li>可采用顺序资源分配法</li>
<li>首先给系统种的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li>
<li>一个进程只有已占有小编号的资源时，才有资源申请更大编号的资源。按此规则，已有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会循环等待的现象。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源消费</li>
<li>必须按规定次序申请资源，用户编程麻烦。</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h3><ul>
<li>用某种方法防止系统进入不安全状态，从而避免死锁</li>
<li>如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li>
<li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。如果有进程提前归还一些资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是考虑到最坏的情况。</li>
<li>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，系统未必发生死锁。但发生死锁移动是在不安全状态。</li>
</ul>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ul>
<li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li>
</ul>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>①检查此次申请是否超过了之前声明的最大需求数</li>
<li>②检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>③试探着分配，更改各数据结构，系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）</li>
<li>④用安全性算法检查此次分配是否会导致系统进入不安全状态。操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</li>
</ul>
<h4 id="安全性算法步骤"><a href="#安全性算法步骤" class="headerlink" title="安全性算法步骤"></a>安全性算法步骤</h4><ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li>
<li>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>长度为 m 的一维数组 Available 表示还有多少可用资源</li>
<li>n*m 矩阵 Max 表示各进程对资源的最大需求数</li>
<li>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源</li>
<li>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源</li>
<li>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</li>
</ul>
<p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608435673_12.png" alt="img"></p>
<h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><ul>
<li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁</li>
<li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
<li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li>
<li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>
</ul>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436005_13.png" alt="img"></p>
<ul>
<li>使用数据结构资源分配图来保存资源的请求和分配信息</li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li>
<li>如果系统剩余的可用资源数满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这些可能又会激活另外一些阻塞的己进程</li>
<li>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）</li>
<li>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li>
</ul>
<h4 id="检测死锁的算法"><a href="#检测死锁的算法" class="headerlink" title="检测死锁的算法"></a>检测死锁的算法</h4><p><img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1608436112_14.png" alt="img"></p>
<h3 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h3><ul>
<li>用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但是所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">icedancemelody</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://icedancemelody.com/2021/07/13/jin-cheng-guan-li/">http://icedancemelody.com/2021/07/13/jin-cheng-guan-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">icedancemelody</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                                <a href="/tags/%E8%BF%9B%E7%A8%8B/">
                                    <span class="chip bg-color">进程</span>
                                </a>
                            
                                <a href="/tags/%E7%BA%BF%E7%A8%8B/">
                                    <span class="chip bg-color">线程</span>
                                </a>
                            
                                <a href="/tags/%E4%B8%AD%E6%96%AD/">
                                    <span class="chip bg-color">中断</span>
                                </a>
                            
                                <a href="/tags/%E6%AD%BB%E9%94%81/">
                                    <span class="chip bg-color">死锁</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">乐</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/07/15/nei-cun-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="操作系统回顾-内存管理">
                        
                        <span class="card-title">操作系统回顾-内存管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-07-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    操作系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                    <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                        <span class="chip bg-color">内存管理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/07/12/cao-zuo-xi-tong-gai-shu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="操作系统回顾-操作系统概述">
                        
                        <span class="card-title">操作系统回顾-操作系统概述</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    操作系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">icedancemelody</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">91.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/icedancemelody" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1542975723@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1542975723" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1542975723" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
